## 前言

**本期是 Swift 编辑组自主整理周报的第九十二期**，各个模块已逐步稳定成型。如果你对内容选题、结构或呈现方式有任何建议，欢迎在文末留言反馈。

Swift 周报已在 GitHub 开源：
[https://github.com/SwiftCommunityRes/SwiftWeekly](https://github.com/SwiftCommunityRes/SwiftWeekly)

欢迎提交 issue、投稿或推荐内容。目前计划 **每两周周一发布**，也非常欢迎志同道合的朋友加入编辑组。

喜欢蝴蝶，不应该把它捏在手中，直到蝴蝶动弹不得。不妨试试低头种花，直到花儿绽放盛开，漫天蝴蝶纷至沓来。👊👊👊

> **周报精选**
>
> 新闻和社区：苹果重组扩大 AI 团队 Apple Intelligence 预计明年初迎来重大更新
>
> 提案：
>
> Swift 论坛：
>
> 推荐博文：

## 话题讨论



## 新闻和社区

### iPhone 18 Pro Max 有望提供新颜色 消息称苹果在考虑酒红色、棕色和紫色

2025 年 12 月 26 日

据外媒报道，苹果公司今年 9 月份推出的 iPhone 17 系列中的 Pro 款和 Pro Max 款，颜色较上一代出现了较大的变化，仅星宇橙色和深蓝色两种可选，上一代中的沙漠色钛金属、原色钛金属、白色钛金属和黑色钛金属均未保留，没有像此前几代一样只调整其中的部分颜色、大部分保留。

![](https://upload.techweb.com.cn/s/1080/imgs/2025/1226/1766715507587.jpg)

而从外媒最新的报道来看，在 iPhone 17 Pro 系列上经历重大调整之后，苹果公司在明年秋季将推出的 iPhone 18 Pro 系列上，仍会对外观颜色进行调整。

外媒在报道中表示，对于 iPhone 18 Pro 系列，苹果公司在考虑的新颜色包括酒红色、棕色和紫色。

但在报道中，外媒尚未提及苹果在考虑的3种新颜色，是会全部出现在 iPhone 18 Pro 系列上，还是只会采用其中的部分。

对于明年秋季将推出的 iPhone 18 Pro 系列，近一段时间有外媒在报道中提到，正面设计将迎来重大变化，用于人脸识别的面容ID将完全置于屏幕下，将不会是近几年灵动岛的药丸状挖孔，前置摄像头虽然仍会有挖孔，但会移至屏幕的左上角。

此外，也有消息称在 iPhone 18 Pro 系列上，苹果公司的自研芯片有望全面升级，A 系列芯片将搭载由台积电采用 2nm 制程工艺代工的 A20 Pro，自研的蜂窝网络调制解调器有望采用升级款的 C2，但也有可能是 C1X，N 系列无线网络芯片也有望升级。（来源：海蓝）

### 苹果重组扩大 AI 团队 Apple Intelligence 预计明年初迎来重大更新

2025 年 12 月 24 日

据外媒报道，过去一年中，约有十几篇报道提到苹果 AI 相关部门的成员和管理者离职，一切都被描绘成苹果末日将至，但事实并非如此。

外媒表示，越来越多证据表明，苹果计划兑现之前的承诺，强调设备端 AI 系统。Apple Foundation Models 将成为更新版 Apple Intelligence（苹果智能）系统的核心，但通过 Private Cloud Compute 集成的第三方模型也将发挥作用。

2025 年，苹果开始重组扩大其 AI 团队。

苹果是一家以保密著称的公司，甚至要求员工模糊其所属团队和日常工作内容。这与 AI 领域的开放文化形成鲜明对比—— AI 研究通常会定期发布公开论文，并署名贡献者。但苹果现在允许 AI 研究人员公开发表研究成果，但这一努力基本被外界忽视。

外媒称，尽管我们仍难以确切知道苹果 AI 团队的规模（只知道有“几十人”），但通过公开论文，我们可以识别出一些成员。即便过去一年有大约十几位重要人物离职，该团队依然运转良好，我们也无从得知苹果的招聘和补充速度。

外媒称，本准备通过研究论文列出苹果 AI 团队成员名单，但在翻了 96 页研究文档中的仅 4 页后，就列出了近 200 个名字。这项任务变得极其庞大，且最终几乎无法产生有价值的结论。

因此可以明确地说，苹果 AI 团队及其各个分支规模相当庞大，并持续公开发表论文。这些研究和数据之所以未能在更广泛的 AI 圈引起关注，可能是因为它们尚未被苹果直接应用——至少目前还没有。

苹果的 AI 团队规模非常庞大，那些关于十几位管理者和一些低级别员工离职的“末日式”报道已经变得荒谬。

简而言之，将每一次离职都解读为具有重大意义，与用供应链数据预测 iPhone 销量一样，毫无用处。

Apple Intelligence 预计将在 2026 年初随 iOS 26.4 迎来重大改版。核心功能将是基于大语言模型的新版 Siri，可通过设备端的 Apple Foundation Models，借助 App Intents 执行任务。

此外，苹果预计还将公布多项合作，将第三方模型引入 Private Cloud Compute。例如，一个定制的谷歌 Gemini 模型可能会接收来自设备端 Apple 模型的数据，并执行网络搜索。苹果将如何应对其 AI 功能的下一阶段，仍有待观察。（来源：新浪财经）

### 苹果强烈要求数亿 iPhone 用户升级至 iOS 26，以应对高危安全威胁

2025 年 12 月 24 日

![](https://files.mdnice.com/user/47553/075593fe-6e43-4163-b266-15e929f91c82.png)

根据苹果最新披露的信息，原本计划作为广泛适用修复版本的 iOS 18.7.3，现已调整为仅支持 iPhone XS、XS Max 和 XR 等特定机型。这意味着更广泛的用户群体——尤其是使用 iPhone 11 及后续型号的用户——无法再通过 iOS 18 系列获得关键安全补丁，必须升级至 iOS 26 才能获取最新防护。

尽管 iOS 26 已于今年早些时候正式发布，但用户采纳率仍不理想。据第三方分析师综合数据显示，目前至少有 50% 的兼容设备尚未完成升级，而仍在运行不符合升级条件旧机型的用户比例低于 10%。低升级意愿可能受存储空间限制、对新界面适应成本以及用户惯性等因素影响。

外媒称，当前安全形势已不容拖延。移动安全公司 Zimperium 指出，全球超过一半的移动设备运行着过时的操作系统版本，使其极易成为网络攻击目标。苹果此次强制升级决定，正是基于多个已被利用的漏洞所构成的“现实且紧迫”的风险。

据科技媒体 9to5Mac 援引苹果惯例预测，下一版本 iOS 26.3 有望于 2026 年 1 月下旬发布，最可能日期为 1 月 26 日（星期一），也可能延后至当周次日。该版本预计将包含常规安全漏洞修补。（来源：环球网科技）

## 提案


## Swift论坛

### 1、提案：将 ArrayBuilder 添加到标准库

作者：Filip Zavolokov ｜ 发布日期：2025 年 12 月 18 日
[阅读原帖](https://forums.swift.org/t/add-arraybuilder-to-the-standard-library/83811 "Pitch: Add @ArrayBuilder to the standard library")￼

该帖提出将 ArrayBuilder 这一构建数组的便利语法加入 Swift 标准库，从而让用户以更直观、声明式的方式构造数组，而无需手动拼接循环或多次调用 append。

核心内容
* ArrayBuilder 是一种构建器（builder）模式，可让你在一个闭包上下文中组合产生数组元素，类似 SwiftUI 的 @ResultBuilder 语法。例如：
```Swift
let nums = ArrayBuilder {
    if condition {
        1
    }
    for i in 0..<3 {
        i
    }
    10
}
// 等价于：[1, 0, 1, 2, 10]（取决于 condition）
```

* 提案希望将这种 API 正式纳入标准库，让所有项目在不依赖第三方代码的情况下，编写更干净、声明式的数组构造逻辑。
* 该构建器可用于任意类型元素数组（Array<T>），并能在控制流（如 if、for）中按语义收集元素。

讨论与反馈亮点

✅ 支持者观点
* 多名社区成员认为这将提升“声明式构造集合”的体验，减少样板代码，尤其在需要根据条件/循环组合元素时更清晰。
* 类似于 String 字面量构造器的便利性，ArrayBuilder 可使复杂数组构造更具表达力。

⚠️ 讨论焦点与保留意见
* 有人提出若简单数组构造可用 ArrayBuilder 实现，是否也应为其他集合（如 Set、自定义容器）提供同类构造器？
* 部分成员提醒注意构建器语法对调试、类型推断的影响，建议在设计时确保错误信息清晰、语义明确。
* 还有讨论是否应将其作为标准库独立模块（如 Collections 附加工具）而非直接嵌入核心模块，降低标准库膨胀风险。

小结

该提案旨在为 Swift 标准库增加一个声明式的集合构造工具 ArrayBuilder，优化数组构造体验。它借鉴 ResultBuilder 语法，可让用户在控制流中组合元素而无需手动管理容器。虽然尚未进入正式进化流程（还处于早期 pitch 或讨论阶段），但已引发社区对“声明式集合构造”这一常见用例的关注。

对希望写出更直观、少样板代码的 Swift 开发者而言，这类构造器是一个值得关注的语言体验增强方向。未来如被采纳，将进一步提升 Swift 在数据构造层面的可读性和表达力。

### 2、提案：为 `swift build` 集成外部遥测服务

作者：Aleksandar Prokopec ｜ 发布日期：2025 年 12 月 18 日
[阅读原帖](https://forums.swift.org/t/proposal-external-telemetry-service-integration-for-swift-build/83806 "Proposal: External Telemetry Service Integration for Swift Build")

这是一项针对 **SwiftPM 构建系统 (`swift build`) 的增强提案**，目标是让构建过程可以选择性地与外部遥测（Telemetry）服务集成，从而帮助分析团队了解真实使用情况、测试覆盖率和构建行为，这对构建性能优化、趋势分析和生态健康监控具有潜在好处。

### 核心内容

* **动机** — 当前 SwiftPM 和 Swift 构建系统在使用遥测/统计时主要依赖 Xcode Cloud、开发者本地工具等，但 **缺少标准化机制** 能让组织或社区服务自动收集构建指标（如：构建时间、缓存命中率、模块构建行为、依赖解析时间等）。这项提案希望通过引入可配置的遥测服务支持，提升生态层面的构建洞察力。

* **遥测集成层级**

  * 遥测**可选**，仅在启用时才发送数据，不会强制开发者上报。
  * 数据上报可针对不同阶段（解析、依赖解决、构建任务调度、链接等）。
  * 上报对象可以是社区/团队自己的遥测后端，无须 Swift 官方托管。

* **隐私与合规**

  * 提案强调必须遵守开发者隐私，不默认收集任何敏感信息。
  * 只有在开发者明确启用遥测并指定服务端点时，才会发送数据。
  * 发送的数据应当仅为结构化的非敏感指标（例如构建耗时、缓存命中百分比等）。

* **扩展机制**

  * SwiftPM 将定义一个插件/扩展点，使第三方服务实现者可以通过注册方式接入自己的遥测终端。
  * 开发者可以通过环境变量或配置文件启用特定的遥测服务和目标。

### 社区反馈与关注点

**支持者观点：**

* 有人认为这可帮助团队或社区 **更好理解构建瓶颈**，从而推动工具链优化。
* 结合 CI/CD 平台（如 GitHub Actions、Azure Pipelines 等）可聚合跨项目构建数据，为语言和包管理器提供有价值的趋势分析。

**审慎或反对意见：**

* 隐私和数据泄露一直是遥测讨论的核心。部分成员担心即便是“非敏感指标”，也可能涉及项目结构、依赖情况等元信息泄露。建议在规范中明确“可控性与最低必要性”原则。
* 有人表示现有 build scripts 或 CI/CD 平台本身有遥测 / 指标收集机制，是否由 SwiftPM 直接承担这一功能需要评估，因为它引入了更多构建系统内的复杂性。

### 小结

这份提案为 Swift 的构建工具链提出了一个**可选性的遥测集成方案**，旨在通过标准化、可配置的方式收集构建指标并上报给外部服务，从而支持团队和社区对构建行为的分析和优化。
它的设计强调隐私保护、可控性和非强制启用；如果采纳，将为 SwiftPM 生态和大型组织的构建优化提供有价值的数据支持。

强调两点：

* **它不是强制功能**，不会默认发送任何数据；
* **关注隐私设计与配置机制**，因为这是采纳此类功能最大争议的焦点。

### 3、庆祝里程碑：我的第一个 PR 被合并到 Swift

作者：Paavo (Swift 社区成员) ｜ 发布日期：2025 年 12 月 18 日
[阅读原帖](https://forums.swift.org/t/a-christmas-milestone-my-first-pr-merged-into-swift/83840 "A Christmas milestone: my first PR merged into Swift")

这是一篇来自 Swift 社区成员 **Paavo** 的热心分享帖，他兴奋地宣布：**自己的第一个 Pull Request 已成功合并进 Swift 编译器仓库**，标志着个人贡献迈出了重要一步。这篇帖子既是庆祝里程碑，也是对社区新贡献者的鼓励。

### 主要内容

* Paavo 分享了自己为 Swift 贡献的第一个 PR 背景：

  * 这个 PR 解决了编译器前端（frontend）在特定场景下的一个边缘错误
  * 修改内容是清晰、局部的，但对于改进 Swift 工具链体验有实质作用

* 他谈到了自己从第一次克隆仓库，到逐渐理解 Swift 编译器架构，再到成功提交、通过 CI 和最终被合并的全过程：

  * 阅读代码、构建工具链
  * 在本地打补丁、自动化测试
  * 与代码审查者沟通、接受反馈
  * 解决 CI 失败并最终获得合并

* Paavo 对社区文化表达了感谢，并鼓励其他“新手贡献者”不要因感到复杂而退缩。

  > “如果有人也想贡献代码，那就从一个小 bug、一个测试修复开始 —— 那些也能改变大家的体验。”

### 核心意义

* **个人里程碑也代表开放文化**
  Paavo 的经历体现了 Swift 社区的开放性：即使是刚开始参与的贡献者，只要提交优质 PR，就有机会被纳入核心项目。

* **增强社区参与感与可见性**
  帖子鼓励大家参与到 Swift 的开发中去，强调了代码贡献的学习过程和价值。

* **新人贡献是编译器/语言生态健康的重要组成部分**
  这类分享往往能让更多开发者觉得“这不是遥不可及的事”，从而带来更多参与和多样化视角。

### 小结

这篇帖子不是技术 proposal，而是社区文化方面的分享：**一位普通开发者成功把自己的第一个 PR 合并到了 Swift 项目中。**它展示了 Swift 生态对新贡献者的友好态度，也提醒大家：即使是小改动也能对语言工具链产生积极影响。

### 4、介绍 Typhoon：一个轻量级的 Async/Await 重试框架

作者：R-Mo (Ruben Munoz) ｜ 发布日期：2025 年 12 月 17 日
[阅读原帖](https://forums.swift.org/t/introducing-typhoon-a-lightweight-async-await-retry-framework-for-swift/83797 "Introducing Typhoon: a lightweight async/await retry framework for Swift")

这篇帖子介绍了 **Typhoon**——一个专为 Swift 的现代并发（async/await）设计的轻量级 **重试（retry）框架**。它的目标是简化常见的异步操作重试模式，让开发者能更安全、清晰、优雅地处理异步调用失败后的重试逻辑，而无需自己重复编写 boilerplate 代码。

## 核心内容

**Typhoon 的设计初衷**
在许多异步场景中（如网络请求、外部服务调用、I/O 操作），调用可能暂时失败。处理这类失败通常需要写出复杂的重试逻辑，如指数退避、最大尝试次数、错误分类处理等。Typhoon 通过一个可组合的 API 抽象这些模式，让使用者更专注于业务逻辑。

## 主要功能特性

### 🔁 简洁的重试策略 API

Typhoon 提供了清晰而可组合的重试策略，例如：

```swift
let strategy = Retry.strategies
    .limit(3)
    .backoff(exponential: .seconds(1))
```

上述策略表示：最多重试 3 次，采用指数退避（每次延迟递增）。

---

### 🧠 重试不同错误类型的能力

可以根据错误类型定义是否重试，例如只对网络错误进行重试，对逻辑错误则立即抛出：

```swift
let result = try await retry(strategy) {
    try await fetchData()
}
```

框架内部针对错误自动决定是否继续重试还是抛出终止。

### 📈 可组合与可扩展

Typhoon 的策略既可组合又可扩展：

* **次数上限**：限制最大尝试次数
* **退避策略**：线性退避、指数退避、固定间隔等
* ** jitter 支持**：可为退避间隔添加随机扰动（抖动），减少并发压力
* **条件重试**：允许用户根据错误上下文判断是否继续

例如：

```swift
let strategy = Retry.strategies
    .limit(5)
    .backoff(exponential: .milliseconds(500))
    .jitter(.default)
```

这个策略在指数退避的基础上添加了默认的 jitter。

## 设计哲学与优势

* **轻量无侵入**：不要求用户改变现有函数签名或引入宏/编译期元编程机制。
* **与 async/await 深度集成**：可以直接用于 async 函数，不改变调用者逻辑。
* **增强可读性**：通过明确定义策略对象，让重试逻辑与业务逻辑分离。
* **可组合性强**：策略可堆叠，可复用，可参数化。

## 使用场景示例

**网络请求重试**

```swift
let data = try await retry(.limit(3).backoff(exponential: .seconds(2))) {
    try await URLSession.shared.data(from: url)
}
```

**条件重试：仅对特定错误重试**

```swift
let result = try await retry(strategy) {
    try await request()
} onError: { error in
    return (error as? URLError)?.shouldRetryNetworkError == true
}
```

## 社区反馈亮点

* 多位开发者欢迎这样的实用库，认为它填补了标准库中缺失的重试模式支持。
* 也有人关注 **如何与现有的 cancel/timeout 机制结合**（例如 Task cancellation、async timeout），并提出是否能够更好支持自定义 “失败聚合报告” 功能。
* 讨论还涉及到如何与 Swift 的 Structured Concurrency 特性（如 TaskGroup）协同处理并发重试场景。

## 小结

**Typhoon 是一个针对 async/await 场景的重试库，它提供干净、可组合、声明式的重试策略 API**，显著减少了开发者在处理失败与重试场景时的样板代码，同时支持策略组合、退避机制和错误过滤。对于经常编写网络请求、远程服务调用、或其他易失败异步操作的 Swift 项目，这个框架可显著提升代码清晰度与可维护性。

建议关注：

* 如何与任务取消/超时配合使用；
* 是否有必要将类似功能演进到标准库工具集；
* 若项目中存在大量异步失败重试逻辑，可评估 Typhoon 作为依赖方案。

---

### 5、讨论：在 Swift 生态中增加对 **zlib** 的支持

作者：Douglas Gregor ｜ 发布日期：2025 年 12 月 17 日
[阅读原帖](https://forums.swift.org/t/zlib-support-in-the-swift-ecosystem/83792 "zlib support in the Swift ecosystem")

这篇帖子就 **在 Swift 生态中更好支持 zlib（通用压缩库）** 展开讨论，重点是如何让 Swift 包、工具链与标准库更方便使用 zlib，而不是依赖社区各自实现或手动集成 C 产物。

## 🔎 背景

* **zlib** 是一个在很多平台上广泛可用的压缩/解压（deflate/inflate）库，许多系统工具、格式（如 gzip、PNG）都依赖它。
* 当前在 Swift 生态中使用 zlib 主要通过手动集成 C 库或使用第三方包（例如 Swift-zlib 绑定），但存在 **跨平台兼容性不一、打包复杂、不同构建系统生成文件不统一** 等问题。

## 🧠 讨论要点

### ✅ 可用性扩展提议

社区讨论认为可以让 Swift 的构建工具（特别是 SwiftPM）更好支持 zlib，例如：

* SwiftPM 内置识别 zlib，在链接时自动查找系统 zlib 并纳入构建；
* 标准库或 SwiftPM 上层库提供统一的 zlib 包装接口（类似 Foundation 对 JSON/BASE64 的支持那样）；
* 为 Linux/macOS/Windows 平台提供一致的发现和链接机制，而不是每个包自己写 `modulemap`、查找路径等。

这种支持可以减轻开发者手动配置 C 互操作和构建集成的负担。

## 📌 兼容性与平台注意

* 在某些平台上（例如 Linux/WSL/部分嵌入式环境），zlib 可能以不同方式分布或名称变化；如何处理 `pkgconfig`、路径查找和版本差异，是核心讨论点之一。
* 一种想法是让 SwiftPM 默认尝试查找 `zlib` 的系统 pkgconfig，并将其作为标准依赖（如同默认支持 libcurl/libz 的模式），降低包作者的维护成本。

## 🛠 社区反馈/建议

讨论中包含以下视角：

* **正向支持者**：认为这是一个常见需求，特别对于网络、文件格式（gzip/zip/PNG/WebP）等库而言，统一 zlib 支持可以让生态更健壮。
* **谨慎角度**：有人指出应避免让 Swift 标准库承担大量 C 库绑定 — 这些可以通过 **SwiftPM 平台快捷集成** 实现，而不是放到标准库内部，从而维持核心库的简洁性。
* **构建脚本改进**：有人建议在工具链层（如 `swift build`）提供更好的 `pkgconfig` 支持和链接器参数推导，而非单纯围绕 zlib，而是为所有系统 C 库统一抽象。

## 🧩 小结

这场讨论并非一个正式提案，而是围绕 **如何在 Swift 生态系统中更好支持 zlib 这类广泛依赖的基础 C 库** 展开。主要关注点包括：

* SwiftPM 在构建和链接阶段更智能地发现系统 zlib；
* 提供统一的 Swift 绑定或接口，减少重复集成工作；
* 提升跨平台一致性——尤其是在 Linux/macOS/Windows 上无缝调用 zlib。

如果您的项目涉及压缩格式、网络传输或多媒体处理，这将是一个值得关注的生态改进方向。未来若能有 SwiftPM 级别的标准支持，将显著降低 C 库依赖集成的复杂度。


## 推荐博文

以下三篇文章非常值得一读，适合本周“提升技能 + 开阔思路”：

[Swift 新并发框架之 async/await ](https://juejin.cn/post/7587349016221810729/ "iOS 知识点 - 多线程总结（Swift 新并发框架之 async/await ")

**摘要：** Swift async/await 是新并发框架的核心，它从根本上重塑了异步代码的写法。它将原本分散嵌套的回调逻辑，转变为直观、线性的同步风格，让代码更易读、更易维护。

其核心在于，用 async 声明可能暂停的函数，用 await 标记调用时的潜在挂起点。关键在于，挂起的是函数而非线程——函数在等待时会释放当前线程，待结果就绪后恢复执行，这避免了阻塞，但也意味着要避免在持锁时跨越 await。

在实际使用中，通过 Task 进入异步上下文，并用 MainActor 确保 UI 更新回到主线程。同时，可以利用续体（Continuation）将现有回调 API 桥接到新的 async/await 世界，实现渐进式迁移。

总的来说，async/await 以更清晰、更安全的方式解决了并发编程的典型痛点，是现代 Swift 开发中提升代码质量和开发效率的关键特性。

[Swift 中 `map`、`compactMap`、`flatMap` 三者的核心区别](https://juejin.cn/post/7583226204033679401/ "Swift 中 `map`、`compactMap`、`flatMap` 三者的核心区别")

**摘要：**  在 Swift 中，map、compactMap 和 flatMap 都是用于对集合进行变换的高阶函数，它们各自承担着不同的数据处理职责。map 专注于一对一的元素转换，保持原有结构不变；compactMap 在转换的基础上，自动过滤掉空值，确保了数据的有效性；而 flatMap 则擅长处理嵌套结构，将多维数据展平为一维序列，简化复杂数据的处理逻辑。

这三者虽功能相似，却各有侧重，共同构成了 Swift 中强大而优雅的数据转换体系。在金融、数据聚合或多层嵌套的业务场景中，合理选择使用它们，可以让代码既安全又清晰，同时保持函数式编程的简洁风格。

[ SwiftUI-Markdown 渲染](https://juejin.cn/post/7511299182264958986/ " SwiftUI-Markdown 渲染")

**摘要：**  这篇文章介绍了 SwiftUI 在 iOS 15 及更高版本中原生支持 Markdown 渲染的功能，使开发者能够轻松在应用中展示格式化的文本。文章详细说明了 SwiftUI 所支持的内联 Markdown 语法，包括加粗、斜体、删除线、内联代码和链接，并提供了具体的代码示例展示如何直接在 Text 视图中使用这些语法。此外，还介绍了通过 String 和 LocalizedStringKey 来渲染 Markdown 文本的灵活方式。虽然当前功能有一定局限，但对于大多数应用场景已足够实用，有助于开发者更专注于内容与用户体验，而无需依赖额外的富文本库。


## 关于我们

**Swift 社区** 是由 Swift 爱好者共同维护的技术组织，主要通过微信公众号运营。

我们专注于 **Swift 实战、SwiftUI、Swift 基础** 三大方向，每周为你带来精选内容与最新生态资讯。

**关注公众号：「Swift社区」**
后台回复 “进群” 即可加入开发者交流圈。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
