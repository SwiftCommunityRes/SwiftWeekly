## 前言

**本期是 Swift 编辑组自主整理周报的第五十期**，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。

Swift 周报在 [GitHub 开源](https://github.com/SwiftCommunityRes/SwiftWeekly "SwiftWeekly")，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。

间歇性的努力和蒙混过日子，都是对之前努力的清零。时间永不停歇，社会时刻发展，**Swift社区**也在华丽蜕变！👊👊👊

> **周报精选**
>
> 新闻和社区：
> 
> 提案：
> 
> Swift 论坛：
>
> 推荐博文：
>
> **话题讨论：** 
> 
> 
>
>**上期话题结果**


## 新闻和社区  


## 提案


## Swift论坛
1) 提议[SE-0439：允许在逗号分隔的列表中使用尾随逗号](https://forums.swift.org/t/se-0439-allow-trailing-comma-in-comma-separated-lists/72876 "SE-0439：允许在逗号分隔的列表中使用尾随逗号")
**内容大概**
这项提案旨在允许在逗号分隔的列表中使用尾随逗号,只要有明确的终止符可以进行无歧义解析。主要动机包括:

1. 提高开发质量:使添加、删除、重新排序或注释最后一个元素变得容易。

2. 语言的演进:Swift 语言和编码风格的发展使得这一特性变得更加必要。

提案的主要内容:

- 在元组、函数参数列表、初始化器、枚举关联值、宏参数、属性、可用性说明等多种场景中允许尾随逗号。
- 在下标、条件语句(if/guard/while)、switch case 标签、闭包捕获列表、继承子句、泛型参数、where 子句和字符串插值中也支持尾随逗号。

详细设计:

- 只有在有明确终止符的情况下才支持尾随逗号。
- 单元素列表允许尾随逗号,但零元素列表不允许。

该提案不会影响现有有效代码的源代码兼容性,但会改变某些无效代码的解析方式。

总的来说,这项提案通过允许更灵活的语法来提高代码的可读性和可维护性。

2) 提议[集合文字](https://forums.swift.org/t/proposal-set-literals/72929 "集合文字")
**内容大概**
该提案旨在将集合(Set)提升为Swift中的一等公民。主要观点包括:

1. 集合类型的重要性被低估,应该得到更多关注。
2. 开发者经常使用数组而非更适合的集合,可能是因为数组声明和使用更简单。

提案的主要内容:

1. 集合类型语法: 使用 `:[Type]` 表示集合类型,例如 `:[Int]` 表示整数集合。

2. 集合字面量语法: 使用 `:[element1, element2, ...]` 创建集合。

3. 可选的集合操作符:
   - `*` 表示交集
   - `*` 或 `~` 表示成员测试
   - `+` 表示并集
   - `-` 表示差集

讨论要点:

1. 对于小型数据集,数组和集合的性能差异可能不显著。
2. 集合的使用应基于对数据结构的理解,而不是盲目选择。
3. 简单类型(如Int、String、枚举等)更适合用作集合元素。
4. 在并发编程中,可发送性(Sendable)是一个考虑因素,但不应成为唯一决定因素。

总的来说,这个提案旨在通过引入更简洁的语法来促进集合的使用,但也引发了关于何时使用集合以及性能考虑的讨论。

3) 讨论[“unless”关键字的优点](https://forums.swift.org/t/merits-of-the-unless-keyword/72909 "“unless”关键字的优点")
**内容大概**
讨论关于引入"unless"关键字的讨论, 作者提出重新考虑引入"unless"关键字的想法,作为"if"的补充对立词。主要观点如下:

1. "unless"的可读性较好,但在"unless...else"结构中可能不太直观。
2. 仅仅为了交换if...else块的顺序并不是一个足够有说服力的理由。
3. 作者常常希望有一个类似"guard"但不要求退出的结构。
4. 引入新关键字会增加Swift的复杂性,需要权衡利弊。
5. 作为替代方案,作者建议考虑引入类似Python的"not"关键字。
6. 总体而言,作者认为"unless"的好处相对较小,但仍值得讨论。

作者还提到,尽管使用Swift多年,有时仍会习惯性地写出"if not ..."这样的语法,并对Swift不支持这种优雅的表达方式感到遗憾。

4) 讨论[为什么 Swift 采用逗号？](https://forums.swift.org/t/why-did-swift-adopt-the-use-of-commas/72906 "为什么 Swift 采用逗号？")
**内容大概**
我之所以问这个问题，是因为我关注目前正在审核的允许尾随逗号的提案 7。

Swift 一开始为什么要使用逗号？

如果没有逗号，解析 Swift 程序会有多难？

有逗号：
```Swift
// Declare function
func foo (arg: Int, arg2: Int)

// Invoke it
foo (arg1: 2, arg2: 2)

// Tuple
var u = (1, 2, 3)

// Array
var v = [1, 2, 3]

// Declare generic functiom
func foo <U, V> (u:U, v: V) -> (U, V)
```
没有逗号：
```Swift
// Declare function
func foo (arg: Int arg2: Int)

// Invoke it
foo (arg:1 arg: 2)

// Tuple
var u = (1 2 3)

// Array
var v = [1 2 3]

// Declare generic function
func foo <U V> (u: U v: V) -> (U V)
```
可以将其视为校验和和纠错码。冗余是关键。即使有效的程序可以在没有逗号的情况下被明确解析，但逗号的存在使得从部分无效的语法中推断含义变得更加容易，甚至使人类能够更快地浏览代码，这也可能导致眼睛和大脑之间的“数据丢失”，而冗余使您能够更轻松地在头脑中重建数据。

5) 讨论[如何知道值类型是否包含堆分配和引用计数](https://forums.swift.org/t/how-to-know-if-a-value-type-includes-heap-allocations-and-ref-counting/72919 "如何知道值类型是否包含堆分配和引用计数")
**内容大概**
讨论围绕着如何知道值类型是否包含堆分配和引用计数

Swift性能特征理解：
1. 堆分配比栈分配更昂贵，并产生引用计数成本。
2. 引用类型（如类）总是使用堆分配。
3. 写时复制(COW)值类型（如Array）也使用堆分配。

问题：
1. Swift没有提供方法来知道值类型是否隐藏了私有引用类型。
2. 难以确定大型结构体的堆分配和引用计数情况。
3. 无法确定Foundation的结构体有多少是NS类的包装器。

建议：
1. Swift文档中应该提供类型的ARC成本和堆分配成本信息。
2. 目前没有很好的方法来确定这些信息。
3. 可以尝试查看类型是否递归包含引用计数字段。
4. 确定类型是否进行手动堆分配的方法是阅读源代码或查找文档。

总结：了解值类型的内存分配和引用计数特征对于优化Swift代码很重要，但目前缺乏有效的工具和文档来获取这些信息。

6) 讨论[如何告诉编译器非隔离对象可以安全地传递到参与者的域中？](https://forums.swift.org/t/how-to-tell-the-compiler-that-the-nonisolated-object-is-safe-to-pass-into-an-actors-domain/72806 "如何告诉编译器非隔离对象可以安全地传递到参与者的域中？")
**内容大概**
问题概述：
作者遇到了一个编译器相关的问题，涉及如何在 Swift 中安全地在 actor 和非隔离对象之间传递数据。具体来说，作者想要告诉编译器，一个旧的 Objective-C 委托和一个 actor 使用相同的底层串行队列，因此在它们之间传递非隔离对象是安全的。

代码示例：
作者提供了一段伪代码，展示了 `Delegate` 类和 `Actor` 类的实现。问题出现在 `Actor` 类的 `usesObject()` 方法中，编译器报错说非可发送类型 `OtherObjCObject` 不能跨越 actor 边界。

当前解决方案：
作者目前的解决方法是为整个包含 `OtherObjCObject` 的库关闭并发检查，但这并不理想，因为该库还包含其他内容。

期望的解决方案：
作者希望能够更精确地告诉编译器，在特定情况下 `OtherObjCObject` 是安全可发送的。例如，能够声明 `var stream: AsyncStream<OtherObjCObject & @unchecked Sendable>` 将会很有帮助，但目前这种语法不起作用。

其他注释：
作者还提到，另一种有用的处理方法是将非 Sendable 对象包装在 @unchecked Sendable 结构中，但在这种情况下，由于需要在 API 调用中进行映射和过滤，这种方法需要将这些细节暴露给公共 API。

总结：
作者正在寻求一种更精确和灵活的方法来处理 Swift 并发中的隔离域和数据传递问题，特别是在处理遗留 Objective-C 代码时。

7) 讨论[为什么当保留计数非零时会调用“deinit”？](https://forums.swift.org/t/why-would-deinit-be-called-when-retain-count-is-non-zero/72924 "为什么当保留计数非零时会调用“deinit”？")
**内容大概**
这个讨论主要涉及Swift类实例在仍被多个对象保留时意外被释放的问题。主要观点如下：

1. 预期行为：类实例只有在不再被强引用（引用计数为零）时才会被释放。
2. 观察到的异常：即使引用计数非零，`deinit` 方法仍被调用。
3. 可能原因：这似乎是编译器或库在处理 `copy` 和存储属性时的一个bug。
4. 问题详情：
   - 在 `copy` 的默认实现中，强引用的存储属性仅通过赋值复制，没有增加引用计数。
   - 这可能是因为 Objective-C 运行时不理解 Swift 存储属性。
   - 即使显式实现 `copy` 并手动赋值存储属性，仍无法增加必要的引用计数。

5. 临时解决方案：使用 `Unmanaged.passRetained(...)` 强制增加引用计数。
6. 潜在风险：如果将来编译器行为改变，这种解决方案可能导致内存泄漏。
7. 疑问：为什么在调用 `deinit` 时引用计数仍为2，原因不明。

总结：这个问题揭示了 Swift 在处理存储属性和 `copy` 操作时的一个潜在 bug，特别是在涉及 Objective-C 运行时交互时。这个问题可能导致对象过早释放，需要开发者注意并采取适当的临时解决方案。

## 推荐博文


## 话题讨论


## 关于我们

**Swift社区**是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 **Swift实战**、**SwiftUl**、**Swift基础**为核心的技术内容，也整理收集优秀的学习资料。

欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
