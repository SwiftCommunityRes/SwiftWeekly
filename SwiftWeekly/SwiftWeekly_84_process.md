## 前言

**本期是 Swift 编辑组自主整理周报的第八十三期**，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。

Swift 周报在 [GitHub 开源](https://github.com/SwiftCommunityRes/SwiftWeekly "SwiftWeekly")，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。

予一半烟火谋生活，许一半诗意得清欢。愿你我一生温柔勇敢，有爱可寻，有梦可追。👊👊👊


> **周报精选**
>
> 新闻和社区：苹果扩大产能 美国市场iPhone 17印度主供货
> 
> 提案：
> 
> Swift 论坛：
>
> 推荐博文：
>
> **话题讨论：** 
> 
> 你怎么看待跨平台语言？
>
>**上期话题结果**




## 话题讨论





## 新闻和社区  

### 苹果健身技术副总裁被指营造“有毒”职场环境，公司发言人否认

2025 年 8 月 22 日

8 月 22 日消息，据《纽约时报》21 日报道，苹果公司健身技术副总裁 Jay Blahnik 近日陷入了负面风暴：多名员工指控他在团队管理中制造了一种有毒职场环境，其行为被形容为“言语辱骂、操纵他人和不当行为（verbally abusive, manipulative and inappropriate）”。

Blahnik 在 2013 年加入苹果，之前长期担任耐克顾问。他负责领导大约 100 人的团队，主导过 Apple Watch 的推出以及 Apple Fitness+ 服务的开发。

目前，他和苹果正面临法律诉讼。一名前雇员已起诉他，而另一宗指控性骚扰的投诉已由苹果私下和解。

消息人士还透露，自 2022 年以来，大约有十分之一的直接下属因健康或医疗原因申请过长期休假，这被外界视作团队氛围不佳的一个信号。苹果内部曾对 Blahnik 进行调查，但公司结论是“未发现不当行为”。一些员工则对《纽约时报》表示，自己觉得公司更在意保护一位明星高管，而不是认真处理基层员工的关切。

苹果在回应中坚决否认报道中的核心说法。公司发言人 Lance Lin 表示：“我们强烈不同意这篇报道的前提，其中包含了许多不实之处和错误解读。”据悉，他同时却拒绝具体说明“所谓的不准确内容”，并强调苹果不会出于隐私原因讨论个别员工事务。“我们会通过法律程序继续澄清事实。”（来源：IT之家）

### 苹果扩大产能 美国市场iPhone 17印度主供货

2025 年 8 月 21 日

据外媒消息称，苹果已经开始了 iPhone 17 系列的量产，苹果这次扩大了在印度市场的产能，在美国市场出售的新款机型，将由印度市场主力供货。

在 Q2 季度中，印度已经成为美国手机市场的最大出口产地，其占据美国市场总销量的 44%，中国出口到美国的手机份额下降到了 25%。

有报道称，苹果有意扩大印度市场的产能，计划在 2026 年推出的 iPhone 18 系列中，完全由印度供货美国市场。

![](https://pics0.baidu.com/feed/242dd42a2834349bd55d6293276b42de37d3bedb.jpeg@f_auto?token=be80710c4aa4ed0f6c0e6f27f5ecc56c)

据悉，苹果 iPhone 17 系列受到关税冲击，将会进行涨价。在 iPhone 17 系列的四款手机中，iPhone 17 标准版保持原价，新款的 iPhone 17 Air 起价 949 美元，比其取代的 Plus 版贵了 50 美元，两款 Pro 版机型的起价同样会提高 50 美元。

也有消息称，苹果将通过潜移默化的方式进行涨价，明面上的价格与上代保持不变，但苹果会砍掉 128GB 存储版本，通过存储溢价来实现涨价。（来源：PChome科技）

### 苹果(AAPL.US)加码印度市场布局，下月将在班加罗尔开设新门店

2025 年 8 月 21 日

苹果公司( AAPL.US )将于下月初在印度南部科技枢纽班加罗尔开设一家新门店，进一步加大对这一关键增长市场的投入。苹果周四在声明中表示，这家门店位于班加罗尔高端商场“亚洲凤凰购物中心”( Phoenix Mall of Asia )，将于 9 月 2 日正式向顾客开放。

苹果目前在印度已运营两家门店：一家是位于印度金融中心孟买的旗舰店，另一家位于德里南部的商场内。2023 年，首席执行官蒂姆·库克曾亲自出席这两家门店的开业仪式。

据市场研究公司 Counterpoint 数据，印度智能手机用户超 7 亿，其中苹果 iPhone 的用户占比为 5%。尽管印度市场在苹果营收中的占比远低于美国和中国，但库克曾表示，这个全球人口最多的国家蕴含巨大增长空间。截至 2024 年 3 月的财年，苹果在印度的营收增长超 30%，达到 80 亿美元，其中绝大部分来自 iPhone 销售。

多年来，苹果一直在努力争取更多印度消费者。在印度，iPhone、iPad 和 MacBook 等产品成为价格高昂的象征，许多人仍无力负担。为此，苹果推出了一系列举措，包括与银行合作提供免息分期购买计划、学生折扣，以及部分产品的免费镌刻服务。

苹果也在不断扩大印度的 iPhone 生产产能。在新冠疫情期间严格封锁措施及各国贸易摩擦的背景下，苹果正逐步减少对中国供应链的依赖。目前，印度已承担超过五分之一的 iPhone 全球产能，且在下一代机型发布前，苹果已在这个南亚国家完成了 iPhone 17 系列全部四款机型的生产。(来源：智通财经网)

## 提案


## Swift论坛
1、讨论[对 Generics 和 Protocols 的挫败感](https://forums.swift.org/t/my-frustration-with-generics-and-protocols/81668 "对 Generics 和 Protocols 的挫败感")
原帖作者 brustolin （Dhiogo Brustolin）表达了 Swift 在使用泛型和协议时的一种困惑，特别是在试图结合弱引用容器与协议类型时遇到编译器限制。这段示例代码引发了挫败感：

```Swift
protocol MyDelegate: AnyObject {
}

final class WeakDelegate<T: AnyObject> {
  weak var value: T?
  init(_ value: T) {
    self.value = value
  }
}

var delegates = [WeakDelegate<MyDelegate>]() // “WeakDelegate requires that 'any MyDelegate' be a class type”
```

而简单写成非泛型、直接使用协议形式却可以通过编译：
```Swift
protocol MyDelegate: AnyObject {
}

final class WeakDelegate {
  weak var value: MyDelegate?
  init(_ value: MyDelegate) {
    self.value = value
  }
}

var delegates = [WeakDelegate]()
```
开发者认为从泛型角度来说，这两段应该在编译时行为一致，甚至希望编译器能够“在泛型约束中将 T 替换成 MyDelegate”，类似于其他语言的模板实例化行为。

社区反馈整理：
* Danny 指出：T: AnyObject 表示“一个引用类型”，而不是协议类型本身。协议 MyDelegate 是约束而非类类型本身，因此泛型写法不成立。他建议明确使用 existential 的新语法，提升清晰性：
```Swift
weak var value: (any MyDelegate)?
init(_ value: any MyDelegate) { self.value = value }
```
￼

* a7medev 进一步解释，本质问题在于 any MyDelegate（协议存在类型）不符合 AnyObject 限制，甚至无法满足 MyDelegate 协议本身。Existential 类型与具体类型的符合关系不同，当前 Swift 尚不支持类似“让 any MyDelegate 隐式符合 AnyObject 或 MyDelegate”这样的写法。可行的替代方案包括使用类型擦除（type erasure）手动包装，但会增加样板代码量。 ￼
* Slava Pestov 从底层机制角度解释，Swift 并不是通过语法静态替换泛型参数来实现泛型（不像 C++ 模板）。泛型与协议存在类型（existentials）是不同层次的抽象。 existential 的用法涉及运行时表示转换，因此不能像手动替换类型参数那样直观。 ￼

总结：这场讨论凸显出 Swift 中 泛型与协议存在类型不统一所带来的语义与结构性困惑。尽管语法直观，开发者期望简洁地使用泛型“弱引用协议类型”，但遇上 existential 类型与 generic constraint 的不兼容，语言当前机制下无法满足。社区回应从理解语言设计本质的角度提供了澄清，也指出现阶段解决问题的常见方式是引入 type-erasure 的包装类，但这带来的样板代码负担也值得关注。

2、提议[Swift AsyncAlgorithms 1.1 版本开发规划](https://forums.swift.org/t/swift-async-algorithms-1-1-planning/81712 "Swift AsyncAlgorithms 1.1 版本开发规划")
由 Philippe Hausler 发布于 2025 年 8 月 19 日的该帖，概述了 AsyncAlgorithms 1.1 的开发方向与版本发布策略，并强调了以特性分组代替时间驱动的发布节奏。 ￼

核心内容整理：
* 维持源码稳定性（source stability）与语义版本
该包自 1.0 版本起承诺不会破坏向后兼容性，公开接口如果要变更只在新 major 版本中进行。 ￼
* 以概念模块为驱动设立版本节奏
于时间周期无关，发布应当围绕有意义的特性集组织，例如当前版本 1.1 将聚焦于“用 Swift 并发替换现有非 Swift-Concurrency 系统”的功能。 ￼
* 版本分支及修复策略
现阶段所有新开发会进行在 main 分支，若 1.0.4 发布后发现 bug，将 cherry-pick 修复到主分支并提升到 1.0.5，确保这些修复也可纳入 1.1。 ￼

总结：这篇帖子为 Swift AsyncAlgorithms 项目定义了清晰的版本管理策略：保持接口稳定性、按特性模块推进版本演进，而非依赖固定时间表。1.1 版本开发已明确以“用 Swift 并发特性替代旧系统”为核心方向，并在分支管理与修复合并方面建立了明确机制。这能帮助开发者设定合理预期，并规划对该库未来迭代的参与。

3、讨论[Swift 编译器对闭包类型检查时诊断信息不足的问题](https://forums.swift.org/t/swift-compiler-diagnostics-when-typechecking-closures-are-not-good/81683 "Swift 编译器对闭包类型检查时诊断信息不足的问题")
该帖由用户 taylorswift 发布于 2025 年 8 月 17 日，指出 Swift 在类型检查复杂闭包时给出的错误信息非常模糊，不利于定位问题。即使闭包外已明确写出类型，编译器依然报出：
```Swift
Type of expression is ambiguous without a type annotation
```

尽管类型声明就在闭包签名处，该提示仍然不具可读性与指示性。帖主的错误正是由于缺少标签的元组签名导致编译失败，并非缺乏类型注解。 ￼

社区反馈要点：
* stackotter 表示也曾遇到类似问题，在链式调用（如 flatMap）与闭包中频繁遭遇诊断信息缺失的状况：“特别是在对 Result 进行了多次 flatMaps 操作时，这种错误信息完全没用。”  ￼
* jamieQ (Jamie) 建议可以将来自 constraint-solving 系统的调试输出（debug output）转化为正式诊断信息，以帮助开发者理解编译器为何无法解出类型：
“…相关推荐诊断信息可能帮助类似情况。我怀疑…难点在于如何在提供有用反馈与避免信息量过载之间取得平衡。”
同时他建议，如果将三元表达式替换为 if-else 结构，有时能让类型检查结果更明确。 ￼
* ibex10 在帖中做了一个自我还原的例子，展示如何通过显式定义参数类型绕过编译错误，显著提升编译器的判断能力。 ￼


总结与建议：

这次讨论反映了 Swift 编译器在处理复杂闭包、嵌套元组、带标签与不带标签类型表达式时，诊断信息缺乏可用性和指导性 的问题。错误提示常常过于通用，无法有效指出“真正的问题在于元组标签缺失”，给开发者排错带来挑战。

社区建议包括：
* 增强诊断信息，将内部 constraint-solving 的 debug 信息适当展示，以提高可理解性；
* 优化提示建议，例如指明缺失标签或可能的格式错误；
* 临时替代方案包括重构闭包为 if-else，或显式写出所有参数与类型，以辅助编译器定位问题。

总的来说，这一问题对 Swift 高度使用闭包及复杂泛型的代码库尤其具有现实危害，改善这些诊断信息是提升开发效率的重要改进方向。


4、讨论[Swift 与第三方 C++ 库互操作的反馈](https://forums.swift.org/t/swift-c-interop-third-party-library-integration-feedback/81716 "Swift 与第三方 C++ 库互操作的反馈")
Ordo One 公司的用户分享了在 Linux 平台上使用 Swift/C++ 互操作（CXX Interop）集成第三方 C++ 库的实践经验与反馈，对该功能的进展表示欢迎，但也指出了当前使用过程中的一些挑战和改进建议。 ￼

主要体验与问题点:
* Pimpl 习惯用法限制
使用 Pimpl（Pointer to Implementation）模式的预编译 C++ 库中，类无法在 Swift 中直接访问，而结构体却可以。这种差异性使人感到困惑。 ￼
* 虚函数重写的难题
若 C++ 类包含需在 Swift 中覆盖的虚函数，只能通过手动封装为另一接口来实现。理想情况是 Swift 能将其识别为 open class，允许直接覆盖——但这在 Swift 与 C++ 类语义差异下可能难以实现。 ￼
* Swift 协议暴露给 C++ 的限制
尝试使用 Swift 协议以替代上述虚函数机制，但目前 Swift 协议尚不能导出至 C++。若能将协议映射为纯虚类，将更灵活。 ￼
* std::function 与 Swift 闭包交互复杂
使用 std::function 和 Swift 闭包作为回调时，实际表现为纯 C 函数形式，需要额外封装，并存在引用传递问题，尤其在处理可变参数时更复杂。 ￼

已观察到的改进进展：
* Swift 6.1 → 6.2 版本间表现出明显改进，包括：
* Swift 生成的头文件（如 MyLib-Swift.h）现在可在 C++ 中导入（之前会报“找不到文件”错误）。
* Linux 上支持将静态库封装在 bundle 中，而以前该功能只在 macOS 有效。
* 一些链接错误已消失，例如涉及原子引用计数的 undefined reference 类型错误。 ￼

其他建议与痛点：
* 希望 Swift 能提供更直接构造 std::optional 的方式（类似 .init(value)），目前此功能缺失显得不方便。
* 频繁出现诸如 warning: 'import_owned' Swift attribute ignored on type 'vector': type is not copyable or destructible 的警告，影响体验。
* 希望支持 Swift 使用 C++ 模板而无需定义别名。
* 在多层 Swift/C++ 模块结构（如 SwiftTarget → CppTarget → SwiftExecutable）中，无法在 C++ 头文件中引用 "SwiftTarget-Swift.h"，导致构建失败。 ￼

总结：

这一讨论为在 Swift 中整合第三方 C++ 库提供了第一手经验，表明虽然互操作已经具备实际可用性，但仍需改善在 Pimpl 模式、虚函数覆盖、协议互用、闭包桥接等关键接口上的开发体验。Swift 6.2 在跨语言编译与链接方面已有显著进步，但社区期待更自然、更简洁、无需大量样板的协作方式。


5、提议[在 Swift 包中支持 Span](https://forums.swift.org/t/supporting-span-in-packages/81667 "在 Swift 包中支持 Span")
Guillaume Lessard 发布了一条关于即将在 Swift 6.2 中引入的 Span 类型家族（包括 Span<T>、RawSpan、MutableSpan<T>、MutableRawSpan、OutputSpan<T> 和 OutputRawSpan，但不包括 UTF8Span）在 Swift 包开发中的使用指南。讲解了其回溯部署（back-deployment）支持、可用性范围及兼容性做法方法。 ￼

主要内容摘要：
* Span 类型引入与平台可用性
Swift 6.2 将新增 Span 类型家族，各类型支持在 Darwin 平台上进行回溯部署（back-deployment），但 UTF8Span 不包括在内。 ￼
* 编译器与平台兼容要求
要在 Swift 包中使用这些 API，必须使用 Swift 6.2 编译器。对于没有稳定 ABI 的平台（如 Linux、Windows、嵌入式系统），这是唯一要求。 ￼
对于拥有稳定 ABI 的平台（例如 macOS、iOS 等），使用 Span 类型的 API 可以运行在较旧系统版本上，包括 macOS 10.14.4、iOS 12.2、watchOS 5.2、tvOS 12.2 和 visionOS 1.0。 ￼
* 实际兼容性处理示例
可通过条件编译和 @available 注解来兼容不同平台。例如扩展 ByteBuffer 时，可这样写：
```Swift
extension ByteBuffer {
  #if compiler(>=6.2)
    @available(macOS 10.14.4, iOS 12.2, watchOS 5.2, tvOS 12.2, *)
    public var someBytes: RawSpan {
      @_lifetime(self)
      borrowing get { /* ... */ }
    }

    @available(macOS 10.14.4, iOS 12.2, watchOS 5.2, tvOS 12.2, *)
    public init(copying bytes: RawSpan) { /* ... */ }
  #endif
}
```
这种写法确保在编译器支持且运行平台符合版本要求的情况下，相关 Span API 才会被引入。 ￼

总结：

这条帖子的核心在于为 Swift 包开发者说明如何安全地使用 Span 类型：借助 Swift 6.2 编译器的能力并控制回溯部署范围，同时通过条件编译和可用性注解，确保包能在尽可能广泛的平台上运行，而不会破坏兼容性。对那些希望在跨平台 Swift 项目中引入 Span 的开发者来说，提供了清晰、可落地的指导路径。

## 推荐博文


## 话题讨论


## 关于我们

**Swift社区**是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 **Swift实战**、**SwiftUl**、**Swift基础**为核心的技术内容，也整理收集优秀的学习资料。

欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
