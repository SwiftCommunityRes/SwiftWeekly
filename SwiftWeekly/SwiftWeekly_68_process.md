## 前言

**本期是 Swift 编辑组自主整理周报的第五十期**，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。

Swift 周报在 [GitHub 开源](https://github.com/SwiftCommunityRes/SwiftWeekly "SwiftWeekly")，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。

间歇性的努力和蒙混过日子，都是对之前努力的清零。时间永不停歇，社会时刻发展，**Swift社区**也在华丽蜕变！👊👊👊

> **周报精选**
>
> 新闻和社区：
> 
> 提案：
> 
> Swift 论坛：
>
> 推荐博文：
>
> **话题讨论：** 
> 
> 
>
>**上期话题结果**


## 新闻和社区  


## 提案


## Swift论坛
1) 讨论[建议：解决边界安全问题](https://forums.swift.org/t/suggestion-tackle-bounds-safety/76516 "建议：解决边界安全问题")

在 Swift 论坛中关于界限安全的讨论中，作者强调界限安全问题的解决应更多依赖开发者优化代码逻辑，而非语言提供额外的安全保障，同时也指出通过合理的优化策略，可以在保证内存安全的同时减少性能开销。
1.	作者承认由于索引越界或范围不正确造成的生产环境崩溃问题，但认为这种问题更多源于开发者的代码习惯，而非语言本身的问题。通过经验积累，作者学会了避免直接操作未知值的索引或范围，从而减少此类问题的发生。
2.	针对在每次下标操作时都检查索引的提议，作者认为这是过于极端的做法。代码中通常存在“入口点”对索引进行验证，一旦索引通过验证，重复检查显得多余。
3.	当前行业推动的“内存安全”语言主要是因为传统的方法难以扩展。然而，这种方法无法完全避免因“远程”操作（如更改底层存储）导致索引失效的漏洞，这可能导致更难调试的崩溃或代码安全问题。
4.	优化界限检查仍有可能。在 WebURL 中，作者自行实现了一种高效的界限检查方法，专注于速度，并尽量让编译器优化掉不必要的检查。
5.	作者计划未来在引入 Span（生命周期保证）后，将这一界限检查策略集成到新包中发布。

2) 讨论[[第二次审查] SF-0007：Subprocess](https://forums.swift.org/t/review-2nd-sf-0007-subprocess/76547 "[第二次审查] SF-0007：Subprocess")

在 SF-0007 提案的第二次审查中，总体来看，SF-0007 提案为 Swift 引入了一个潜力巨大的子进程 API，但在细节上还需要进一步优化和澄清，尤其是在跨平台一致性、闭包隔离、性能优化等方面。
1.	第一次审查总结：
该提案得到了很多积极的评论，认为这是现有 Process API 的良好替代方案。然而，也有一些需要作者进一步澄清的问题，包括如何管理存活时间长于父进程的子进程，如何在进程间传递输出，以及一些平台特定 API 的处理问题。
2.	开发者反馈：
* 闭包发送：一些方法要求闭包是发送类型（sending），这使得它们在与其他代码组合时变得不那么容易。希望能探讨是否可以重构实现，使其不需要这一要求。
* 闭包隔离：提案中的方法似乎缺少对“隔离”（isolated）的参数，这在使用 actor 隔离的上下文中会导致数据竞争问题。
* AsyncSequence 的性能问题：讨论了使用 AsyncSequence 可能导致的性能问题，并希望能进一步基准测试。
* 平台特定类型：提案中使用了像 pid_t 和 DWORD 这样的平台特定类型，是否可以考虑直接使用 Int 来代替？
* ProcessIdentifier 类型：关于 ProcessIdentifier 的命名和不同平台的属性存在一定的疑问，是否可以在所有平台上统一为 .value？
* 未管理的子进程：有观点认为，未管理的子进程应与文件描述符的直接传递解耦，避免混合不同的概念。
* 使用 FileDescriptor 和 FilePath：目前 swift-system 并不包含在工具链中，因此提案中如何在公有 Foundation API 中使用这两个类型仍需进一步讨论。
* 拆解顺序：提案中的拆解方法需要更明确的文档说明，以避免使用者产生混淆。
* ExecutionResult 的 Sendable 类型：提案中 ExecutionResult 需要一个 Sendable 类型，但为何必须是 Sendable 类型仍不清晰。
* 小修改建议：建议使用更长的泛型参数名称，提供更常见的信号类型，调整 sendSignal 的参数标签等。

3) 讨论[LSP 与 CMake 和 nightly 工具链集成](https://forums.swift.org/t/lsp-integration-with-cmake-and-nightly-toolchains/76508 "LSP 与 CMake 和 nightly 工具链集成")

在关于 LSP 集成与 CMake 和夜间工具链的讨论中，作者提出在集成 LSP 与 CMake 的过程中，开发者应灵活选择合适的工具链，并关注生成文件的正确配置，特别是在处理项目构建和编译标志时。VSCode 提供了更好的自定义工具链支持，而 Xcode 的兼容性可能有限。
1.	Xcode 与工具链支持：
Xcode 的工具链支持存在不稳定性，开发者可能会遇到兼容性问题。相比之下，VSCode 的 Swift 插件提供了更好的工具链设置功能，允许用户自定义工具链，并应用于所有功能。但 Xcode 会使用其内部版本的工具链，且在处理苹果平台时，可能无法满足工具链的要求。
2.	构建问题与建议：
有些用户在尝试构建项目时遇到问题。特别是，对于使用 CMake 的项目，可能需要尝试不同的生成器（如 CMake generate 或 Ninja generate），以确定哪个适合自己的项目。用户也应该检查生成的文件，确保所有文件都列在其中。
3.	使用 compile_flags.txt：
对于有库的项目，建议使用 compile_flags.txt 风格的配置，而不仅仅是默认的 CMake 配置。这可以帮助更好地管理编译标志。
4.	配置文件与生成问题：
一些配置（如 generatedFilesPath 或 index）可能可以简化生成过程，避免需要单独的 compile_commands.json 文件。虽然目前尚不明确如何完全实现这一点，但仍建议通过配置文件进一步探索解决方案。

4) 讨论[在‘@Sendable’中捕获self……请停止它！](https://forums.swift.org/t/capture-of-self-in-a-sendable-please-make-it-stop/76463 "在‘@Sendable’中捕获self……请停止它！")

在关于 @Sendable 的讨论中，作者指出@Sendable 和 @unchecked Sendable 机制的设计目的是为了帮助开发者捕捉并发问题，并避免潜在的并发错误。虽然开发者可以选择关闭这些警告，但需要承担起确保线程安全的责任，否则可能会导致数据损坏和崩溃。
1.	编译器的警告作用：
编译器发出的警告并非针对开发者，而是为了提醒潜在的并发问题，尤其是可能发生的不安全访问。编译器认为，当模型（通常是引用类型）被并发访问时，可能会引发并发问题，建议开发者审查代码。
2.	@unchecked Sendable 使用：
如果开发者确定自己能安全地管理同步问题，可以通过标记类型为 @unchecked Sendable 来告诉编译器“我能确保这是安全的”，即使编译器无法进行进一步的检查。这是开发者对编译器的一种承诺，表明他们将负责确保并发安全。
3.	崩溃的有效性：
如果开发者违反了这种承诺并进行了不安全的访问，崩溃是合理的。处理并发问题时，编译器会倾向于立即崩溃，而不是让潜在的错误悄悄存在，避免数据损坏。
4.	编译器与开发者的关系：
尽管开发者可能感到编译器过于严格或烦人，但从编译器的角度，严格的并发检查有助于避免错误，确保代码的安全性。这类似于 C/C++ 等语言中的指针操作，虽然它们提供了更多自由，但也容易导致空指针访问等错误。
5.	@unchecked Sendable 是否关闭警告：
@unchecked Sendable 不会影响运行时，而是作为一个标记协议，告诉编译器在并发访问时可以放心地传递类型，但开发者需要对并发安全负责。如果不小心使用了类型，可能会导致并发错误。

5) 提议[Expose attosecond representation of `Duration`](https://forums.swift.org/t/pitch-expose-attosecond-representation-of-duration/76522 "Expose attosecond representation of `Duration`")

在关于 Duration 类型attosecond表示的提案中，作者通过引入对 Int128 类型的支持，使 Duration 类型更易于使用，特别是在需要高精度时间计算的场景中，减少了冗余代码，提高了性能和可读性。
1.	提案介绍：
该提案的目的是通过引入新的 Int128 类型，允许开发者更方便地访问 Duration 类型的飞秒（attosecond）表示，并简化从飞秒创建 Duration 值的过程。
2.	当前 Duration 类型的局限性：
当前的 Duration 类型有两种方式来构造和分解：一种是低位和高位的属性 _low 和 _high，另一种是通过 components 属性将其分解为秒和飞秒。虽然这些方式有效，但在处理 Duration 的总飞秒表示时存在一些局限性。例如，要生成一个随机 Duration，开发者目前需要编写冗长且低效的代码。
3.	提案的动机与解决方案：
通过引入 Int128 类型支持，提案简化了这一过程。开发者可以通过新的计算属性 attoseconds 和新的初始化器 init(attoseconds: Int128) 直接处理 Duration 的飞秒表示，从而避免了复杂的分解和运算。
4.	详细设计：
新提案通过将 _low 和 _high 属性统一为一个 Int128 类型的表示，提供了更简洁高效的 API。新增的属性 attoseconds 返回 Duration 的总飞秒数，而新的初始化器允许通过传入一个 Int128 来直接创建 Duration 实例。

## 推荐博文


## 话题讨论


## 关于我们

**Swift社区**是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 **Swift实战**、**SwiftUl**、**Swift基础**为核心的技术内容，也整理收集优秀的学习资料。

欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
