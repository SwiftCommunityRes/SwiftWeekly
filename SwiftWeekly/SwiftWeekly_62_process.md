## 前言

**本期是 Swift 编辑组自主整理周报的第六十二期**，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。

Swift 周报在 [GitHub 开源](https://github.com/SwiftCommunityRes/SwiftWeekly "SwiftWeekly")，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。

人生两条路，一条在心中，唤作梦想，一条于脚下，叫做现实。**Swift社区**不扰繁华，不论悲欢，点头于心，踏步向前！👊👊👊

> **周报精选**
>
> 新闻和社区：苹果、华为“撞档”上新引海外关注
> 
> 提案：
>
> Swift 论坛：
>
> 推荐博文：
>
> **话题讨论：** 
> 
> 
>
>**上期话题结果**


## 新闻和社区  

### 苹果、华为“撞档”上新引海外关注

2024 年 9 月 13 日

本周，苹果公司、华为公司相继举行新品发布会，推出各自最新创新产品。中美两家高科技企业“撞档”上新，备受科技界及国际舆论关注，中国科技企业的创新能力引热议。
苹果公司推出了 iPhone 16 系列智能手机和苹果手表等新品。华为公司发布了全球首款三折叠屏手机，在铰链系统、屏幕弯折等方面实现多项技术突破。一些媒体在报道中对两家公司的发展状况及新产品进行对比。
美国“石英”财经网站撰文称，华为自去年 8 月发布 Mate 60 Pro 系列智能手机以来，在中国市场的表现优于苹果。今年 4 月，华为发布的报告称其利润连续第四个季度实现增长，这凸显了华为在美方制裁和打压下展示出的韧性。
“反观苹果，其 iPhone 销量同期下降了 19%，这是自 2020 年新冠疫情以来苹果在中国市场表现最糟糕的一次。今年一季度，苹果在中国智能手机市场的份额从 19.7% 跌至 15.7%。面对华为和其他中国本土智能手机制造商的激烈竞争，苹果不得不下调部分机型在中国市场的价格。”报道称。
美国消费者新闻与商业频道（CNBC）报道称，华为在 2019 年美国对中国科技企业实施制裁打压后遭受重创，如今在智能手机领域强势回归。华为及其他中国智能手机企业已在销售折叠屏手机，而苹果尚未进军该领域。
知名技术市场分析公司卡纳利斯咨询公司研究经理安伯·刘对媒体表示，华为和苹果新品发布时间相近，标志着中国高端市场新一轮竞争浪潮的开始。关键竞争领域将包括高端产品、软件功能和人工智能部署。华为的快速复苏“直接挑战到”苹果在中国市场的表现。中国是苹果的全球第二大市场，占其全球出货量的 20% 以上。
卡纳利斯咨询公司发布的数据显示，今年二季度，苹果在中国市场的出货量被挤出前五，排名退至第六。前五位首次被中国国内手机品牌包揽。
美国网络公司美国在线（AOL）以“苹果公司中国竞争对手华为抢了 iPhone 16 风头”为题撰文称，每年秋季苹果发布新款 iPhone 时，都是智能手机领域的绝对霸主。然而今年，其在中国最大的竞争对手之一华为在努力“改写剧本”。
美国有线电视新闻网报道称，美国此前的限制措施当时让华为的智能手机发展受到沉重打击，但如今华为再次“重返巅峰”，同时还在进军新业务。去年华为推出了一款与特斯拉 Model S 竞争的电动车。华为在人工智能发展方面也有远大抱负。
两家中美企业发布的最新产品也引来一些媒体和业内人士的评测。印度新闻网站“今日商业”撰文称，苹果的 iPhone 16 系列虽然有一些改进，但与上一代相比并没有引入任何重大变化。相比之下，华为的新款折叠屏手机提供了突破性的设计和许多高科技功能。华为一直高度重视折叠屏手机市场，这次发布的新产品进一步巩固了其地位。
路透社报道称，苹果最新发布的 iPhone 16 未能让投资者兴奋，因为大家期待已久的新产品中的人工智能功能仍处于测试模式。而华为推出业界首款三折叠屏手机，在争夺全球智能手机市场主导地位的斗争中继续加码。
科技新闻网站 technology.org 撰文指出，折叠屏手机的兴起反映了消费者对智能手机屏显更加灵活、外形更加新颖有更高的期待。华为推出的三折叠屏手机 Mate XT 等设备展示了功能和美学的融合，这是智能手机设计的未来发展方向。同时，人工智能技术的深度融合也是未来智能手机技术革新的一大重要趋势。Mate XT 体现的领先人工智能技术不仅能提升用户体验，同时能变革使用者与人工智能技术的互动。(来源：新华社)

### 苹果公司发布新品

2024 年 9 月 10 日

![](https://pics1.baidu.com/feed/1ad5ad6eddc451dac78ded3795aec968d1163250.jpeg@f_auto?token=404ef52ccf1826b1dd0bc3e5b4439367)

9月9日，在美国加利福尼亚州丘珀蒂诺市举行的苹果新品发布会后，人们体验新品。
当日，苹果公司举行新品发布会，推出iPhone 16系列智能手机和苹果手表等新品。(来源：光明网)

![](https://pics6.baidu.com/feed/4e4a20a4462309f7f9f48b35575d97fdd6cad6db.jpeg@f_auto?token=3d070b60a102b3ba0b21b97e077ac6f6)

### 现已推出针对自动续期订阅的赢回优惠

2024 年 9 月 10 日

![](https://devimages-cdn.apple.com/wwdc-services/articles/images/36DAEB9E-B718-4A1A-B6F6-F35FB864E810/2048.jpeg)

现在，你可以在 App Store Connect 中配置回头客优惠，这是一种针对自动续期订阅的新优惠。借助回头客优惠，你将能触达之前的订阅者，鼓励他们重新订阅你的 App 或游戏。例如，你可以创建提前支付优惠，对于标准续订价格为每年 39.99 美元的订阅项目，前六个月享受 9.99 美元的优惠价。Apple 会根据你的优惠配置，在不同位置向符合条件的顾客显示此类优惠，这些位置包括：

App Store 上的多个位置，包括你的产品页面，以及“Today”、“游戏”和 “App”标签页上的个性化推荐和编辑精选。
你 App 或游戏内的适当位置。
你通过自己的营销渠道分享的直接链接。
“订阅”设置。
在 App Store Connect 中创建回头客优惠时，你需要确定顾客资格，选择地区提供情况，并选取折扣类型。从今年秋季开始， 回头客优惠将向符合条件的顾客显示。

## 提案


## Swift论坛

1) 讨论[SwiftIfConfig 库正在取代编译器的 #if 处理](https://forums.swift.org/t/swiftifconfig-library-is-replacing-the-compilers-if-handling/74411 "SwiftIfConfig 库正在取代编译器的 #if 处理")
内容大概：
Swift编译器正在经历一项重大更新，新的SwiftIfConfig库将取代编译器中对#if指令的处理。这个库是swift-syntax包的一部分，目前已完成多个关键改进：

	1.	配置区域的实现：为IDE中的#if折叠功能提供支持，增强代码覆盖率分析。
	2.	替换C++解析器中的#if条件逻辑：使大部分旧的ParseIfConfig.cpp代码不再需要，优化了对#if条件的解析。
	3.	在ASTGen中支持#if指令：新解析器通过支持#if，提升了处理复杂语法结构的能力。
	4.	基于#if条件输出语法错误：根据#if指令的配置情况来决定哪些语法错误需要打印。
	5.	删除遗留的“内联文本”提取逻辑：进一步简化了编译器中的代码。

接下来的工作是从C++语义AST中彻底移除IfConfigDecl，这一改变不仅能使编译器代码更简洁，还能提高#if在不同语法规则中的扩展性。此外，这次更新还会保留一些重要的编译器行为，例如在不活跃的#if块中抑制变量未使用的警告，以及抑制try和throw相关的警告。

在SourceKit方面，多个查询已被swift-syntax和swift-format工具取代，更新会废弃旧的查询并在下一个Swift版本中完全移除这些处理#if的查询。与此类似，Swift编译器前端的swift-indent模式也将被移除，因其功能有限，且已有更现代的工具（如swift-format）可供使用。

总体而言，这次更新将Swift编译器中的#if处理逻辑迁移到swift-syntax库中，极大简化了主编译器的代码基础，标志着一大进步。

2) 提议[重新审视允许更多非标识符字符的反引号分隔标识符](https://forums.swift.org/t/pitch-revisiting-backtick-delimited-identifiers-that-allow-more-non-identifier-characters/74432 "重新审视允许更多非标识符字符的反引号分隔标识符")
内容大概：
本文提出再次允许在反引号（backticks）中使用包含空格和其他非标识符字符的标识符。过去曾提出过类似的提案（SE-0275），但被拒绝。本文试图基于新的信息和使用经验重新审视该提案。

1. 描述性测试命名：
之前的拒绝理由之一是希望测试框架能够提供不同的方法来为测试用例附加字符串。虽然新的swift-testing框架已经实现了这一点，但当前的方法要求用户为测试命名两次，这不仅冗余，还引入了不一致。例如：
```Swift
@Test("tapping pushes the nav stack")
func tappingPushesTheNavStack() {
    // 测试代码...
}
```
这种方法导致测试报告和测试UI中使用描述性名称，但调试器、回溯以及代码导航工具仍使用函数声明名。为了避免这种不一致，本文建议允许函数名直接使用描述性名称，例如：
```Swift
@Test func `tapping pushes the nav stack`() {
    // 测试代码...
}
```
2. 模块命名：
在大型代码库中，模块命名是一个挑战。当前的做法是将模块构建目标路径转换为有效的标识符名，例如：
```Swift
import my_cool_project_ui_navigation
```
但这种做法增加了自动化工具的复杂性，特别是在处理依赖关系和导入管理时。本文建议允许直接使用包含非标识符字符的路径作为模块名，例如：
```Swift
import `my/cool/project/ui/navigation`
```
这将简化导入语句并减少自动化工具的复杂性。

3. 其他注意事项：
提案还讨论了与工具链的边缘情况和潜在的未来方向。例如，建议通过定义一个字符集来限制反引号中的允许字符，以增强对未来Unicode扩展的适应性。

总结：该提案旨在简化代码中的测试命名和模块命名，同时减少不必要的复杂性，并提高代码的可读性和一致性。

3) 讨论[如果没有办法拦截“fatalError”，则会对服务器造成危害](https://forums.swift.org/t/fatalerror-without-a-way-to-intercept-it-is-harmful-on-the-server/74386 "如果没有办法拦截“fatalError”，则会对服务器造成危害")
内容大概：
在服务器端使用Swift时，fatalError 无法被拦截是有害的。虽然通过将功能隔离到Docker容器中，并自动重启失败的容器，可以在一定程度上缓解问题，但在生产环境中，代码无论多么理想化，都会因各种原因导致崩溃。Swift早期编译器版本中的无效代码、缺失库调用导致的致命错误、内存泄漏等问题，都可能导致容器崩溃。

有两种应对严重错误的思路：一种是类似Erlang的“快速失败”方法，失败时生成新的轻量级进程再次执行代码；另一种是更常见的方法，假设大多数异常不会破坏内存，程序可以继续运行。fatalError() 的设计假设这些错误不符合程序模型，并且假设大多数代码在隔离的进程中运行。这种方法是否适用于服务器端的Swift，尤其是在使用结构化并发时，仍然有待验证。

总的来说，Swift需要根据不同的应用场景来调整对严重错误的处理策略，特别是在服务器环境下。

4) 讨论[并行计算 DAG/共享未来？](https://forums.swift.org/t/parallel-computation-dag-shared-futures/74404 "并行计算 DAG/共享未来？")
内容大概：
本文讨论了如何在Swift中并行化计算任务。具体任务可以描述为以下函数：
```Swift
func compute(_ input: [Key]) -> [Key: Value]
```
该函数的结果包含所有输入中的键，还会生成一些在计算过程中发现的额外键。存在一个依赖有向无环图（DAG），描述所有值之间的依赖关系。

通过一个简单的例子展示了计算的形式，例如计算整数n的阶乘并将其映射到字典中：
```Swift
func compute(_ input: [Int]) -> [Int: Int] {
    var r: [Int: Int] = [:]

    func fact(_ x: Int) -> Int {
        if let y = r[x] { return y; }
        let y = x == 0 ? 1 : x * fact(x - 1)
        r[x] = y
        return y
    }

    for z in input { _ = fact(z) }
    return r
}
```
本文提出了一种可能的并行化方案：在最终的for循环中为每个输入元素启动并行任务。同时，考虑到DAG的结构，一个键的值的计算可能依赖于另一个键的值，如果该键的值已经在另一个线程中开始计算，那么该计算可能会暂停等待。这种情况类似于共享Future系统。

此外，作者希望在每个线程中批量处理计算结果，并且只在批量足够大时将结果合并到最终结果中，以减少同步的开销。同时，允许某些键值对被重复计算，以避免使用共享的Future系统。

本文希望通过讨论找到合适的并行计算解决方案。

5) 讨论[关于“间接枚举”语义的澄清](https://forums.swift.org/t/clarification-about-semantics-of-indirect-enum/74366 "关于“间接枚举”语义的澄清")
内容大概：
最近作者在工作项目中建议将一些枚举标记为 indirect，以减少它们占用的栈内存。然而，在解释 indirect 实际上做了什么时，我发现很难清楚地说明，除了引用编译器内部机制之外。

官方文档中关于 indirect enum 的唯一提及是“递归枚举”，这是最常见的使用场景。然而，还有其他有效的使用场景，论坛上也经常讨论这些，但从官方文档来看，这是否是预期用途并不明确。

作者认为值得更明确地记录 indirect 在底层实际做了什么，并提到它在内存优化场景中的作用。虽然语言本身从未“官方”保证某些内容的内存分配方式，但了解其在不同场景下的行为会有所帮助。

例如，一个常见的场景是链表类型使用 indirect enum 实现。编译器可能足够智能，可以证明某个链表在函数内不逃逸，从而将堆分配转化为动态栈分配。

另一个例子是全局常量的值是 indirect enum，目前生成的代码会执行堆分配，但理论上可以将这些间接情况放入静态空间。

此外，由于 indirect 的情况是不可变的，因此不能对这些盒子的引用标识做出任何保证，除非使用不安全的技巧来观察其标识。

## 推荐博文

[在 Swift 中引入对 Oblivious HTTP 的支持](https://www.swift.org/blog/introducing-swift-nio-oblivious-http/ "在 Swift 中引入对 Oblivious HTTP 的支持")

**摘要：** 这篇官方文章介绍了 Swift 中对 Oblivious HTTP（OHTTP）的支持，并发布了新的 SwiftNIO 包 SwiftNIO Oblivious HTTP。Oblivious HTTP 通过加密 HTTP 请求并结合第三方中继服务，保护客户端的身份信息，增强隐私性，避免暴露诸如 IP 地址等数据。

SwiftNIO Oblivious HTTP 包提供两个主要库：

ObliviousHTTP：实现了 RFC 9292 中定义的二进制 HTTP 编码方案和 Oblivious HTTP。
ObliviousX：提供加密功能的 API，支持 Oblivious HTTP 及其他数据的加密。
文章通过代码示例演示了如何使用这些库进行 HTTP 消息的序列化、反序列化和加密解密。还提到了未来的开发计划，包括与 SwiftNIO 更好的集成、对其他 Swift 类型的支持，以及对分块 OHTTP 的支持。

SwiftNIO Oblivious HTTP 仍处于早期开发阶段，期待社区的反馈和贡献。。

[Swift 中的任务和任务组](https://juejin.cn/post/7409991384970149914/ "Swift 中的任务和任务组")

**摘要：** 这篇博客介绍了 Swift 中的任务（Task）和任务组（Task Group），并讲解了它们的使用方法及相关高级技巧。

**任务（Task）**是 Swift 并发编程的一部分，允许在非并发环境中创建并发任务，任务在创建后立即运行。文章展示了如何创建任务、处理任务的错误和取消任务。Swift 提供了 `Task.checkCancellation()` 主动抛出错误终止任务，或通过 `Task.isCancelled` 检查任务是否被取消。还介绍了如何设置任务优先级和任务的生命周期状态（运行中、暂停、取消和完成）。

**任务组（Task Group）**用于组合并发执行的多个任务，并等待所有任务完成后返回结果。通过 `withTaskGroup` 或 `withThrowingTaskGroup` 可以创建任务组，并发执行任务。文章提供了如何处理任务组中的错误、如何避免数据竞争，并展示了取消任务组的用法。

最后，作者强调了避免并发修改任务组的操作，推荐使用 `cancelAll()` 来取消任务组中的所有子任务，以及 `addTaskUnlessCancelled()` 来确保任务组未被取消时才添加新任务。。

[递归枚举在 Swift 中的妙用](https://juejin.cn/post/7413311432970928168/ "递归枚举在 Swift 中的妙用")

**摘要：**  这篇博客介绍了 Swift 中递归枚举的使用及其优势。递归枚举允许枚举的某些情况包含自身实例，适用于建模层次化或递归结构的数据，如文件系统。通过 indirect 关键字，Swift 可以安全地处理递归引用，避免内存问题。

文章首先展示了如何用递归枚举实现文件系统模型，并引入了文件、文件夹和别名的概念。然后通过代码示例，展示了如何使用递归枚举创建嵌套文件结构，并递归计算文件夹中的总项目数。

此外，文章还解释了在引用自身时如何正确使用 indirect 关键字，并指出当引用通过集合类型（如数组）实现时，不需要 indirect 标记。


## 话题讨论


## 关于我们

**Swift社区**是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 **Swift实战**、**SwiftUl**、**Swift基础**为核心的技术内容，也整理收集优秀的学习资料。

欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
