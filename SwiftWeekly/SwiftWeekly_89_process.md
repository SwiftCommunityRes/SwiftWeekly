## 前言

嗨，Swift 社区的小伙伴们～👋

欢迎来到 **第 88 期 Swift 周报**！每次写到这个数字，总有种陪大家一起成长的感觉。过去几周，Swift 社区依然热闹非凡：苹果又一次站上市值高峰、Swift 官方提案频出、论坛讨论异常活跃，还有不少开发者分享了很棒的实践文章。

**送给大家**：“清晨的风轻轻吹过，带来的是新的希望和挑战。无论昨日有多少困惑，今天的你依然有无限的可能性。带着微笑，走向新的精彩。👊👊👊”

> **周报精选**
>
> * 新闻和社区：马斯克起诉OpenAI和苹果最新进展：两家公司撤诉申请被驳回
> * 提案：
> * Swift 
> * 推荐博文：

**上期话题投票结果**


## 本期话题讨论


欢迎留言参与投票，我们将在下期公布结果。

## 新闻和社区

### 马斯克起诉OpenAI和苹果最新进展：两家公司撤诉申请被驳回

2025 年 11 月 14 日

![](https://pics2.baidu.com/feed/d50735fae6cd7b89d0fa19deb3d186b7db330eda.jpeg@f_auto?token=10d4c7bb406d342207b861c6eb9b33de)

马斯克对苹果和 OpenAI 两家公司的起诉有新进展。当地时间 11 月 13 日，美国得克萨斯州联邦法官裁定，苹果公司和 OpenAI 必须回应马斯克旗下人工智能公司 xAI 提起的诉讼，驳回了苹果和 OpenAI 要求撤销诉讼的申请，法官要求双方提交进一步文件阐述各自立场。

今年 8 月，马斯克在社交媒体平台发文称：“X 平台是全球排名第一的新闻应用，而 Grok 在所有应用中排名第五，为什么苹果公司拒绝将 X 或 Grok 列入苹果商店‘必备’类别？”他还表示，苹果公司的行为使得 OpenAI 以外的任何 AI 公司都无法在苹果商店排行榜中排名第一，“这无疑违反反垄断法”，xAI 将立即采取法律行动。

对于马斯克的指控，苹果公司和 OpenAI 均进行了回应。OpenAI 首席执行官山姆·奥特曼在社交媒体平台上转发前者帖文并表示：“鉴于我听说有指控称马斯克通过操纵 X 谋取个人及公司利益，并损害其竞争对手和他不喜欢的人的利益，马斯克的一番言论令人震惊。我希望有人能对此展开调查，我和许多人都想知道究竟发生了什么。但 OpenAI 将专注于打造卓越产品。”

苹果公司发言人则回应称，该平台通过排行榜、算法推荐及专家精选榜单展示应用，“所有推荐均遵循客观标准”，并称其目标是“为用户提供安全探索环境，同时为开发者创造公平竞争机会”。苹果公司强调其应用商店“秉持公平原则，不存在偏袒行为”。

此后 8 月 25 日，马斯克旗下公司正式在美国得克萨斯州联邦法院起诉 OpenAI 和苹果公司，指控他们非法合谋阻挠人工智能竞争。诉讼称，OpenAI 控制着美国生成式 AI 聊天机器人市场约 80% 的份额，而苹果则占据了智能手机市场约 65% 的份额。

同时作为特斯拉 CEO 的马斯克，本月赢得了一场重大胜利。在特斯拉年度股东大会上，股东们以 75% 的多数票通过马斯克的“万亿美元薪酬方案”。同时在部分股东弃权的情况下，特斯拉股东大会投票支持特斯拉投资马斯克旗下的 xAI 。这项投资决定虽然有利益冲突的嫌疑，但被认为有利于特斯拉和xAI两家企业的发展。

最新有报道称，xAI 在 E 轮融资中筹集了 150 亿美元。马斯克则发文称，关于 xAI 在 E 轮融资中筹集 150 亿美元的消息是“不实”的。(来源：界面新闻)

### 事关苹果公司抽成比例，微信传来好消息！腾讯也回应了

2025 年 11 月 14 日

腾讯公司已与苹果公司达成一项协议，根据该协议，苹果将处理微信小游戏和应用中的支付事宜，并从中抽取 15% 的分成。

11 月 13 日，在腾讯控股 2025 年三季度业绩电话会议上，有投资者提问该市场消息是否属实。

对此，腾讯高管在业绩会上回应称，腾讯与苹果有很好的关系，在不同领域展开合作，也在持续沟通推动小游戏生态进一步发展，目前可以说对当前进度持建设性态度，具体内容还需等待官方公告。

在去年 8 月腾讯的二季度财报电话会上，腾讯首席战略官詹姆斯・米切尔也首次承认，腾讯正在与苹果就微信小游戏的收入进行谈判，探索通过iOS支付系统提供应用内交易的方式，这将使苹果开始从游戏内交易中分成，但双方能否达成一致尚存疑。

事实上，苹果对 App Store 上的应用开发者一直有“抽成”惯例。2017 年时，苹果发布新版 App Store 审核规定，将虚拟货币打赏视为应用内购买，要求必须走苹果支付渠道，苹果从中提取 30% 的分成，“苹果税”由此而来。

目前，苹果对年收入 100 万美元以上的应用，其内部发生的数字内容消费收取 30% 的分成，对年收入 100 万美元以下的中小开发者抽成比例为 15%。

据第三方数据统计机构 Sensor Tower 统计，2023 年，“苹果税”在全球大约收入 223.4 亿美元（约合人民币 1506 亿元），而仅在中国，这一数字就超过 400 亿元。

值得一提的是，消息传出当日，腾讯还发布了三季度财报，公司第三季度实现收入 1928.69 亿元，同比增长 15%；实现净利润 631.33 亿元，同比增长 19%。（来源：每日经济新闻）

### iPhone Pocket 发布：以美妙方式将 iPhone 随身穿戴

2025 年 11 月 11 日

iPhone Pocket 源自 ISSEY MIYAKE 与 Apple 的合作，采用一体式三维编织构造，可容纳任意 iPhone

![](https://www.apple.com.cn/newsroom/images/2025/11/introducing-iphone-pocket-a-beautiful-and-wearable-carrier-for-iphone/article/Apple-iPhone-Pocket-and-ISSEY-MIYAKE-hero_big.jpg.large.jpg)

ISSEY MIYAKE 与 Apple 今日联袂推出 iPhone Pocket。iPhone Pocket 以“一块布”为设计灵感，采用一体式三维编织构造，可容纳任意 iPhone 与各种便携小物。从 11 月 14 日（周五）起，iPhone Pocket 将通过法国、大中华区、意大利、日本、新加坡、韩国、英国和美国的部分 Apple Store 零售店与 apple.com.cn 发售。
iPhone Pocket 采用棱纹开放式结构，彰显 ISSEY MIYAKE 标志性的褶皱质感。其低调设计源自创造“多一个口袋”的灵感，可完全容纳 iPhone，并可延展以装下更多用户常用小物。开放式编织结构拉伸后会含蓄地展示内部物件，用户便可看到 iPhone 显示屏。用户可通过多种方式携带 iPhone Pocket，包括手持、附着于包上、直接穿戴在身上等。iPhone Pocket 配色鲜艳活泼，短带款提供八种色彩外观，长带款提供三种色彩外观。

![](https://www.apple.com.cn/newsroom/images/2025/11/introducing-iphone-pocket-a-beautiful-and-wearable-carrier-for-iphone/article/Apple-iPhone-Pocket-and-ISSEY-MIYAKE-short-strap-colors_big.jpg.large.jpg)

“iPhone Pocket 的设计彰显了 iPhone 与用户之间的联结，同时秉承了 Apple 产品风格统一、用途丰富的设计理念。”三宅设计事务所设计总监宫前义之表示，“iPhone Pocket 探索了‘以自己的方式穿戴 iPhone 的快乐’这一概念。其设计的简洁呼应了 ISSEY MIYAKE 的理念——尽量少去定义事物，才能为更多可能性与个性解读留出空间。”
“Apple 和 ISSEY MIYAKE 都遵循崇尚技艺、简洁和愉悦的设计方法。”Apple 工业设计副总裁 Molly Anderson 表示，“这个巧妙的‘附加口袋’正是这些理念的绝佳范例，与我们的产品堪称珠联璧合。iPhone Pocket 的配色旨在混搭我们所有 iPhone 及其色彩，供用户打造自己的个性化搭配。它以极具辨识度的轮廓为用户提供了携带 iPhone、AirPods 和日常心爱小物的美妙新方式。”

![](https://www.apple.com.cn/newsroom/images/2025/11/introducing-iphone-pocket-a-beautiful-and-wearable-carrier-for-iphone/article/Apple-iPhone-Pocket-and-ISSEY-MIYAKE-cinnamon-with-iPhone-17-Pro_big.jpg.large.jpg)

iPhone Pocket 在日本制造，采用 ISSEY MIYAKE 研发的一体式三维编织结构。这种设计的灵感源自“一块布”的概念，对品牌标志性褶皱面料的日常实用价值进行了重新诠释。iPhone Pocket 的开发与设计在 ISSEY MIYAKE 与 Apple 设计工作室的密切合作下展开，后者全程为设计与生产提供洞察建议。

![](https://www.apple.com.cn/newsroom/images/2025/11/introducing-iphone-pocket-a-beautiful-and-wearable-carrier-for-iphone/article/Apple-iPhone-Pocket-and-ISSEY-MIYAKE-lemon-and-mandarin-with-iPhone-17-and-iPhone-Air_inline.jpg.large.jpg)

iPhone Pocket 是特别版产品。短带款提供八种色彩外观：柠檬色、柑橘色、紫色、粉色、孔雀绿色、宝石蓝色、肉桂色和黑色；长带款提供三种色彩外观：宝石蓝色、肉桂色和黑色。短带款 iPhone Pocket 售价为 RMB 1,299，长带款售价为 RMB 1,899。
11 月 14 日（周五）起，法国、大中华区、意大利、日本、新加坡、韩国、英国和美国的顾客可通过部分 Apple Store 零售店及 apple.com.cn 购买 iPhone Pocket。Apple Specialist 专家会在零售店内及线上帮助顾客根据自己的 iPhone 搭配合适的长度和色彩，并购买心仪新配件，迎接节日季到来。

## 提案


## Swift论坛

### 1、支持 ~Copyable、~Escapable 在标准库简单协议中

作者：Ben Cohen ｜ 发布日期：2025 年 11 月 7 日
[阅读原帖](https://forums.swift.org/t/support-copyable-escapable-in-simple-standard-library-protocols/83083 "支持 ~Copyable、~Escapable 在标准库简单协议中")

这是一项针对 Swift 标准库协议的小而关键的提案，目标是让这些协议能够兼容“非可复制（non-Copyable）”和“可逃逸（Escapable）”类型，从而进一步推动 Swift 新的所有权模型在生态中的采用。

**核心要点：**
* 提议将以下协议声明为精炼（refine） ~Copyable 与 ~Escapable：
* Equatable, Comparable, Hashable
* CustomStringConvertible, CustomDebugStringConvertible
* TextOutputStream, TextOutputStreamable
* 同时，将 LosslessStringConvertible 标记为精炼 ~Copyable。  ￼
* 此外，提案建议更新 Optional 与 Result 的 Equatable/Hashable 关联条件，使其支持元素类型满足 ~Copyable & ~Escapable 的情形。  ￼
* 提出该变更不会改变现有语义或破坏兼容性，而是扩展协议的可适用类型集合。  ￼
* 提案背景：目前标准库协议大量依赖于类型为 “可复制” 或 “不可逃逸” 的假设，这限制了将非可复制类型或资源型类型（如唯一所有权结构）用于这些协议的情况。通过该变更，可让这些类型更方便地参与如 Hashable、Equatable 等通用协议。  ￼

**小结：**

如果你的代码或库即将采用 Swift 的所有权模型（非可复制类型、借用/消耗语义）——那么这项提案是极其有意义的。它删减了因为标准协议“假定可复制／不可逃逸”而导致的障碍，让更多种类的类型能参与生态内常用协议。你可在未来项目中留意：当标准库版本支持后，可尝试将自定义非可复制类型也纳入 Equatable、Hashable、CustomStringConvertible 等协议。这将提升资源型类型的可用性与通用性。

### 2、为任意 Swift PM 包生成文档的提案

作者：Chris McGee ｜ 发布日期：2025 年11 月12 日
[查看提案](https://forums.swift.org/t/pitch-documentation-generation-for-any-swiftpm-package/83174 "为任意 Swift PM 包生成文档的提案")

这则 pitch 提出了一个简化并标准化 Swift 包文档生成流程的建议：通过新增 swift package generate-documentation 命令，让任何使用 DocC 的 SwiftPM 包能“一键生成” HTML API 文档，而无需手动配置插件、symbol-graph、archive 合并等繁琐步骤。 ￼

**核心要点：**
* 动机：目前虽然 DocC 能生成 API 文档，但对包作者而言，配置门槛高、流程繁琐，许多包因此缺乏优质文档。 ￼
* 提案：将文档生成流程内置于 SwiftPM，通过新命令自动发现产品／目标、生成 symbol graph、合并多个目标文档并输出为统一浏览结构。示例界面如下：
```bash
swift package generate-documentation
```
无需手动指定具体 target。 ￼

* 理想效果：包作者与使用者均能快速浏览包的 API、模块结构与文档内容，从而提升 Swift 社区中包的可发现性与可用性。
* 符合生态趋势：随着 DocC 与 SwiftPM 的深度融合，该提案希望将文档生成变为默认而非附加操作。

**小结：**
如果你或你的团队正在维护 SwiftPM 包，尤其是希望提高包的文档质量与使用友好度，这一提案值得密切关注。一旦实现，你将能更轻松地为你的库发布在线文档，而无须额外插件或复杂配置。建议在周报中提醒团队：在该命令支持后可立即评估迁移路径。

### 3、通用化 ContiguousBytes 以支持 Span 等类型

作者：Douglas Gregor ｜ 发布日期：2025 年11 月 7 日
[查看提案](https://forums.swift.org/t/pitch-generalize-contiguousbytes-to-support-span-et-al/83082 "通用化 ContiguousBytes 以支持 Span 等类型")

这篇 pitch 针对标准库中的协议 ContiguousBytes 提出了增强建议：让它能够支持新引入的“连续存储视图”（如 Span、RawSpan 等）以及“非可复制（non-Copyable）”和“不可逃逸（non-Escapable）”类型，从而提升其适用范围。

**核心要点：**
* 背景：ContiguousBytes 目前用于表示能够输出其底层字节存储（如 Data, Array<UInt8> 等）并提供 withUnsafeBytes 闭包访问。 ￼
* 问题：新的 Span 类型家族设计为轻量 “借用视图”，可能是不可逃逸或非可复制类型，因此当前 ContiguousBytes 限制其 Self: ~Copyable, ~Escapable 无法使这些类型符合协议。 ￼
* 提案：修改 ContiguousBytes 定义，将其要求调整为更加通用：
```Swift
public protocol ContiguousBytes: ~Escapable, ~Copyable {
    func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
    func withBytes<R, E>(_ body: (RawSpan) throws(E) -> R) throws(E) -> R
}
```
同时让 Span, MutableSpan, RawSpan, MutableRawSpan, UTF8Span, InlineArray 等类型都符合该协议。 ￼

* 讨论要点包括：
* 是否应优先使用 withBytes(RawSpan) 而非传统 withUnsafeBytes。
* 如何处理旧 API 与新 API 的交互、可用性注解（availability）与编译器支持。 ￼

**小结：**

对于希望在 Swift 中使用低级字节视图或固定容量/借用数组等新型存储类型的开发者而言，这项提案具有重要意义。它可让这些类型与现有标准库字节接口兼容，从而简化诸如序列化、数据解析、网络字节流等场景的 API 设计。建议项目团队关注该提案的进展，并在未来考虑采用 Span 类型及其字节访问优化。

### 4、恢复提议：为元组自动生成 Hashable 一致性（SE-0283）

作者：Joshua Cleetus ｜ 发布日期：2025 年 11 月 9 日
[阅读原帖](https://forums.swift.org/t/pitch-automatic-hashable-conformance-for-tuples-revival-of-se-0283/83105 "恢复提议：为元组自动生成 Hashable 一致性（SE-0283）")

这篇 pitch 提出了一个实用而常见的改进建议：当元组的所有元素都遵循 Hashable 协议时，让编译器自动将该元组类型识别为 Hashable。这项功能意在节省手动扩展元组协议的一致性代码，并促进元组在诸如 Dictionary 或 Set 中作为键的使用。

核心要点如下：
* 痛点描述：目前，尽管 (Int, String) 的元素类型 Int 和 String 均为 Hashable，但元组 (Int, String) 本身并不自动符合 Hashable，因此不能直接用作字典键。提案指出这是与语言可读性和生态惯例不一致之处。  ￼
* 提案方案：当元组 (T0, T1, …, Tn) 中每个 Ti 都符合 Hashable 时，自动生成如下扩展：
```Swift
extension (T0, T1, …, Tn): Hashable
  where T0: Hashable, T1: Hashable, …, Tn: Hashable
{
  public func hash(into hasher: inout Hasher) {
    hasher.combine(0)         // 类型判别符，防止不同元组混淆
    hasher.combine(self.0)
    hasher.combine(self.1)
    …
    hasher.combine(self.n)
  }
}
```
注：== 运算符对于元组元件数不超过 6 已由标准库通过重载提供，无需再次生成。  ￼

* 适用规则：
* 若且仅若所有元组元素均遵循 Hashable，元组即自动符合 Hashable。
* 若任何一个元素不符合 Hashable，则该元组不自动符合。
* 嵌套元组、元素为元组、元素为数组（如 Array<T> 若 T: Hashable）等均支持。  ￼
* 兼容性与实现影响：
* 仅为新增自动一致性，不会破坏现有代码，因为没有移除任何功能；手动扩展的情形仍可用。
* 对 ABI 无影响，因为这是源级扩展，不涉及运行时布局改变。  ￼
* 历史背景：
* 原提案 SE-0283（2020）曾被接受，目标让元组同时自动符合 Equatable、Comparable 和 Hashable。  ￼
* 但因“非名义类型（non-nominal type）”自动一致性实现在运行时/编译器中存在挑战，最终被撤回。  ￼
* 该 pitch 是对 SE-0283 的“限定复兴”——聚焦仅 Hashable 且待编译器对元组一致性支持成熟。  ￼

**小结：**
这项提案虽看似“小改”，但对于许多使用元组作为复合键、缓存标识、数据结构的开发者而言，是一个极具可用价值的提升。若被采纳，将大幅减少样板代码，并提升元组类型在 Swift 生态中的整合度。但其是否会实施，仍取决于编译器对于“非名义类型自动协议一致性”底层机制的成熟度。


### 5、为什么 removeLast(_:) 不返回值？

作者：Matt Neuburg ｜ 发布日期：2025 年 11 月 10 日
[阅读原帖](https://forums.swift.org/t/why-doesnt-removelast-return-a-value/83116 "为什么 removeLast(_:) 不返回值？")

在这篇讨论中，用户 Matt Neuburg 提出一个长期困扰：在 Swift 中，removeLast() 会移除并返回最后一个元素，但其重载方法 removeLast(_:)（移除多个元素）却仅移除而不返回这些元素。他认为从“最少惊讶原则（Least Surprise Principle）”出发，removeLast(_:) 理应返回被移除的元素集合。讨论中标准库团队成员及其他用户给出了性能与设计层面的解释。

核心观点：
* 问题背景：虽然 removeLast() 在 Array 等可变集合类型上移除最后一个元素并返回它，但 removeLast(_ n: Int) 仅移除最后 n 个元素，不返回它们。Matt 指出自己每次都必须先做 let removed = array.suffix(n)，然后再 array.removeLast(n)，感觉繁琐且容易出错。  ￼
* 标准库团队解释（Tony Allevato）：当只移除一个元素时返回值「廉价」且直观；但若移除多个元素，若要返回这些元素，就必须在移除前复制它们或生成一个切片（slice）保持原始存储。两者皆可能带来性能开销：
* 返回 slice：需保留原底层存储直到切片销毁，可能禁用 COW 优化。  ￼
* 复制数组：若大多数用户不需要返回值，这将给所有人埋下不必要开销。  ￼
* 社区建议与延伸思考：
* 可以通过扩展提供 removeLastAndReturn(_:)（或类似命名）手动实现返回值行为。  ￼
* Ben Cohen 指出：随着 Span 等轻量视图类型引入，未来或许可以为此类方法返回“消耗视图（draining span）”——类似于 Rust 中 drain 的概念，在不额外分配的情况下返还移除元素。  ￼

**小结：**

这个讨论虽然不是语言提案，而是 “为什么如此设计” 的反思，对日常 Swift 开发者依然有价值。若你所在项目常用 removeLast(_:) 移除多个元素且需要获取它们，建议采取以下实践：
* 若需要被移除元素，先做 let removed = array.suffix(n) 再 array.removeLast(n)。
* 或者封装一个自定义扩展方法（如 removeLastAndReturn(_:)）明确返回 ArraySlice 或 Array。
* 关注未来标准库是否会针对此情景增强 API（例如支持 Span 或类似技术）。

## 推荐博文
[Swift 6.2 性能革新](https://blog.csdn.net/qq449245884/article/details/154585510/ "Swift 6.2 性能革新")

**摘要：** 这是一篇对Swift 6.2版本的深度分析文章，虽然来自个人博客，但对新特性的解读非常详细。它主要讨论了以下关键更新：

Inline Arrays（内联定长数组）：允许数组数据直接存储在栈上，减少了堆分配和引用计数的开销，对于游戏、金融和媒体处理等高性能计算场景，能带来数倍的性能提升和显著的内存占用降低。

Span 类型：提供了一种安全且高效的方式来操作连续内存，类似于C语言的指针但更具安全性，非常适合处理音频、图像等缓冲区数据。

并发模型改进：优化了Actor隔离推断和结构化并发，使得并发代码更易于编写和维护，减少了与编译器的“角力”。

[SwiftUI 新Tab API实战](https://blog.csdn.net/qq_36478920/article/details/154802726/ "SwiftUI 新Tab API实战")

**摘要：**  这篇博客通过代码示例，手把手教你如何使用SwiftUI的新API来创建符合iOS 18新设计语言（Liquid Glass）的标签栏。

新旧写法对比：展示了从传统的tabItem写法到新的Tab结构体的转变，使代码层次更清晰。

状态绑定：讲解了如何结合@SceneStorage来持久化用户选择的标签页状态。

标签角色：介绍了TabRole机制，例如可以将某个标签设为.search角色，系统会为其应用特殊的样式。

[Swift 内存管理：吃透 ARC 、weak、unowned](https://juejin.cn/post/7571693273729007652/ "Swift 内存管理：吃透 ARC 、weak、unowned")

**摘要：**  Swift 的内存管理核心在于理解 ARC（自动引用计数）的自动化机制与局限性。它虽然能自动处理大部分内存，但当对象之间产生“强引用循环”时，便会陷入内存泄漏的困境。破解此困境的关键在于正确使用 weak 和 unowned 这两把钥匙：weak 提供了一种安全的观察者模式，在对象销毁时自动退场；而 unowned 则假设了一种更紧密的生命周期绑定，性能更高但风险自担。本质上，精湛的 Swift 内存管理是一门在“自动化便利”与“手动干预责任”之间寻求平衡的艺术，要求开发者不仅能设计对象之间的关系，更能预见它们从生到死的完整生命周期。


## 关于我们

**Swift 社区** 是由 Swift 爱好者共同维护的技术组织，主要通过微信公众号运营。

我们专注于 **Swift 实战、SwiftUI、Swift 基础** 三大方向，每周为你带来精选内容与最新生态资讯。

**关注公众号：「Swift社区」**
后台回复 “进群” 即可加入开发者交流圈。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
