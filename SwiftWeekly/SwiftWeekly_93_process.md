## 前言

**本期是 Swift 编辑组自主整理周报的第九十三期**，各个模块已逐步稳定成型。如果你对内容选题、结构或呈现方式有任何建议，欢迎在文末留言反馈。

Swift 周报已在 GitHub 开源：
[https://github.com/SwiftCommunityRes/SwiftWeekly](https://github.com/SwiftCommunityRes/SwiftWeekly)

欢迎提交 issue、投稿或推荐内容。目前计划 **每两周周一发布**，也非常欢迎志同道合的朋友加入编辑组。

这世界或许千疮百孔，但总有一隅温柔在等待我们踏足。就仿若这世间没有真正的成长，只有不断破碎又重组的生命力在呐喊。👊👊👊

> **周报精选**
>
> 新闻和社区：苹果税全球博弈升级，谁能真正逼苹果低头？
>
> 提案：
>
> Swift 论坛：
>
> 推荐博文：

## 话题讨论

## 新闻和社区

### 罚款或达380亿美元 印度监管机构为反垄断新法与苹果交锋

2026 年 1 月 8 日

1 月 8 日资讯，苹果公司此前针对印度一项反垄断处罚法提出抗辩，原因是该法以企业全球营业额为基础计算罚款。而印度反垄断监管机构则辩称，这项法律可对跨国公司形成更强震慑，从而遏制违法行为。

印度竞争委员会仍在调查印度初创企业联盟以及 Tinder 母公司 Match 提出的投诉，这些公司指控苹果存在“滥用行为”，迫使开发者为应用内购买支付高额佣金。

印度竞争委员会调查人员 2024 年发布初步报告称，苹果在其 iPhone 操作系统 iOS 的应用市场中实施了“滥用行为”。该机构尚未就此案作出最终裁决，包括是否罚款。

印度在 2024 年推出的反垄断新法规定，印度竞争委员会在对滥用市场支配地位的公司处以罚款时，可依据其全球营业额进行计算，而非仅基于其在印度境内的营业额。

2025 年 11 月，苹果在德里高等法院提起诉讼，要求法官撤销该法律。苹果在递交给德里高等法院的文件中称，若按过去三财年（截至 2024 年）全球服务业务平均营业额的 10% 计算，苹果的“最大罚款风险”可能高达 380 亿美元。

印度竞争委员会在 12 月 15 日的一份法院文件中首次详细阐述其立场，称该法律“使印度竞争法执法与既有的国际惯例保持一致”。

该机构补充称，若仅以企业在印度境内的营业额作为罚款计算依据，尤其是在全球性数字企业的案件中，将不足以对相关违法行为形成有效威慑。

苹果还指责印度竞争委员会在另一宗案件中非法追溯适用这项新法律。该公司称，印度竞争委员会于 11 月 10 日在另一无关案件中首次启用新规，将这一规则追溯适用于涉事企业十年前的违规行为。

印度竞争委员会对此予以否认，并称其一直拥有最高可处以企业营业额十分之一罚款的权力，新法律只是澄清了营业额的定义方式。

印度竞争委员会表示：“澄清性条款具有追溯适用效力，因为它们解释了立法机关的真实意图。”

根据日程安排，德里高等法院定于 1 月 27 日审理该案。（来源：财联社）

### 苹果一名设计师跳槽AI初创公司 曾参与设计iPhone Air

2026 年 1 月 8 日

1 月 8 日消息，据外媒报道，扎克伯格担任 CEO 的 Meta，去年下半年挖走了苹果 AI 团队的多名工程师，其中包括基础模型团队领导者 Ruoming Pang 这一关键人物，而在年底，他们又挖走了苹果的用户界面（UI）设计主管艾伦・戴伊（Alan Dye），并任命他为首席设计官，领导 Meta 新成立的设计工作室，负责软件和硬件方面的设计，重点是改进带有人工智能功能的头显和眼镜等。

![](https://upload.techweb.com.cn/s/1080/imgs/2026/0108/1767841384114.jpg)

而从外媒最新的报道来看，在艾伦・戴伊被挖走之前，苹果还流失了一名重要的设计师。

就外媒的报道来看，在艾伦・戴伊之前离开的苹果设计师是 Abidur Chowdhury，他是 iPhone Air 的一名设计师，在 11 月份离开了苹果。

对于 Abidur Chowdhury 离开苹果之后的去向，外媒称他加入了 Brett Adcock 创立的 AI 初创公司 Hawk。Brett Adcock 是人形机器人公司 Figure AI 的 CEO，他投入 1 亿美元的自有资金创立了 Hawk。

外媒在报道中提到，Abidur Chowdhury 在加入 Hawk 之后，是担任设计主管，但并未提及更多的细节信息。不过有外媒在报道中提到，Hawk 将研发 AI 模型，如果属实，Abidur Chowdhury 的工作就将与 AI 模型有关。（来源：海蓝）

### 苹果税全球博弈升级，谁能真正逼苹果低头？

2026 年 1 月 5 日

就在年前，苹果选择了又一次上诉。

据《卫报》2025 年 12 月底报道，苹果公司已向英国法院提出上诉，寻求推翻一项涉及 15 亿英镑且有里程碑意义的裁决，核心就在于「苹果税」。去年，伦敦国王学院学者代表约 3600 万英国（iPhone 及 iPad）消费者向法庭提起集体诉讼，指控苹果 App Store 的超额收费，要求退还 15 亿英镑，并于 10 月胜诉。

苹果并没有选择和解，也没有主动调整规则，而是继续向法院提起上诉。对苹果来说，这并不是一次孤立的法律动作，更像是一种条件反射，只要触及 App Store 的核心利益，就一定要把战线拉长、把问题拖深。

英国显然不是个例，过去几年围绕「苹果税」的博弈几乎在全球展开。

在欧盟，《数字市场法》（DMA）逐步生效后，苹果被迫整改，包括放开第三方支付、第三方 App 商店以及佣金计费方式修改等；在美国，Epic Game 诉苹果垄断案的判决以及司法部的反垄断诉讼，都迫使苹果放开外链，允许开发者引导用户在 App Store 外进行付费；在日本，《特定智能手机软件竞争促进法》也迫使 iPhone 开放第三方支付和应用分发渠道，降低抽成。此外，还有韩国、印度、澳大利亚等地监管机构也在围剿「苹果税」。

从表面看，苹果似乎在不断「让步」：佣金下调了，外链能放了，第三方支付甚至分发也允许了。但换一个角度看，这些变化几乎都发生在被监管或法院逼到墙角之后，而且每一次「让步」都伴随着更复杂的规则、更精细的收费设计，确保真正受到冲击的只是形式，而不是「苹果税」本身。

在美国市场最初放开外链后，苹果仍然要收取 27%的佣金，对于中小开发者综合成本明显高于以往。日本市场也是同理，苹果「新规」出台后，有开发者就抱怨脱离 App Store 后成本不降反增，中小开发者还是困于「苹果税」。

在轮番围剿之下，苹果真的退让了吗？中国能从这些博弈中学到什么？要知道，直到今天，中国开发者仍然面临全球最高、也最没有选择空间的「苹果税」。

「顽抗」的苹果税：改变，但未必让步
回头看这场持续多年的「苹果税」之争，会发现苹果并不是一开始就遭遇全球围剿。而最早真正把问题推到台前的，是一家游戏引擎和分发平台公司 Epic Games。

Epic 起诉苹果时，外界一度以为这会是一场「平台垄断」的正面对决。但最终结果并没有那么戏剧化，法院并未否定 App Store 的整体模式，却明确要求苹果不得再禁止开发者引导用户使用外部支付渠道。

苹果的第一反应，当然不是接受这个结果。除了上诉，苹果在舆论层面也试图把焦点从「生态高墙」「抽成过高」，转移到「生态安全」，对外强调如果允许外部支付，用户将面临诈骗、隐私泄露和退款无门的风险。对内则开始研究，如何在「遵守判决」的同时，把损失控制到最低。

2024 年美国最高法院驳回苹果上诉后，苹果宣布允许美国开发者在 App 内放置外链，引导用户到外部完成购买。但前提是，这类交易仍然要向苹果支付 27% 的佣金。从数字上看，这似乎比原来的 30% 有所下降；但实际操作中，由于开发者还需要承担外部支付渠道的手续费，这种「外链交易」对于中小开发者来说反而更贵。

更关键的是，后来曝光的法庭文件显示，这套 27% 的方案，并非临时决定，而是在判决前半年就已内部敲定。苹果财务副总裁亚历克斯·罗曼在庭审中宣称相关决定是在「公告当天才做出的」，但法官随后认定这一证词与内部会议记录不符，直指其作伪证，并将案件移交检察官评估是否涉及刑事责任。

显然，苹果不敢不遵守判决，但仍然不断尝试将对判决的「遵守」变成另一种形式的对抗，在某种程度上也可以视为一种「恶意合规」。而同样的套路也出现出现在欧盟。

欧盟《数字市场法案》（DMA）的核心目标非常直接：作为「守门人」的平台，不得通过规则限制竞争，不得阻止开发者和用户使用第三方支付或其他分发渠道。

面对压力，苹果在 2024 年宣布「遵循 DMA」，但一边推出了一套全新的、更加复杂的佣金计费，一边还在对第三方支付和侧载设置阻碍。名义上，欧盟区的苹果税从 30% 降到了 17%，部分开发者甚至只需支付 10%，但开发者实际要交的佣金种类更多了。

欧盟的调查结果还显示，苹果在过程中设置了大量障碍，比如不允许在应用提供价格信息、跳转外链弹出系统警告等方式，使用第三方支付也要向苹果支付的「核心技术费」。与此同时，苹果官方从报道到新闻稿也一再强调《数字市场法》对欧盟用户的负面影响。

![](https://pics7.baidu.com/feed/6159252dd42a2834ca3b73a88542cefb17cebff9.jpeg@f_auto?token=e6653b793acf6efae861a131581df9fd)

到了日本，苹果的策略已经显得更加成熟，甚至可以说更「精细」。日本通过《特定智能手机软件竞争促进法》后，明确要求苹果开放第三方应用商店和支付方式。表面上看，苹果这一次给出了更积极的回应，佣金比例下调了，支付路径变多了，选择似乎前所未有地丰富。

但真正的变化，藏在细则里。在新的日本规则下，开发者可以选择应用内支付、网页支付，甚至在 App Store 之外分发应用，但每一种路径都对应着不同的费用结构：

应用内支付要交 21% 的佣金，小型开发者是 10%，但还要额外支付 5% 的 IAP 处理费；网页支付要交 15%；而一旦选择侧载或第三方商店，还需要支付 5% 的「核心技术费」，并向苹果提交完整的每月交易报告。

算到最后，许多日本中小开发团队发现一个尴尬的现实：法律给了选择权，但苹果重新定义了「选择的成本」。游戏制作人 Ukyo 就直言，对中小企业来说，脱离 App Store 几乎没有什么好处。团队测算结果也表明，5%的核心技术费，加上使用外部支付产生的交易费用，客户支持成本、初始开发成本以及维护/运营费用可能会不降反增。

![](https://pics4.baidu.com/feed/a9d3fd1f4134970a7559afbb4a3dd6d9a6865d00.jpeg@f_auto?token=34b70e4e433dc574bb6f89a88e229f47)

从美国到欧盟，再到日本，苹果的路线已经非常清晰。面对罚款，苹果选择能诉尽诉，能拖尽拖；面对立法必须「让步」，但与此同时制定了一套足以让新法目标落空的具体规则。而这，也正是各国监管真正警惕的地方。

博弈升级，苹果吃硬不吃软
苹果宣布在日本市场对 iPhone 开放第三方应用商店和外部支付渠道后，12 月 18 日，Epic Games 创始人兼 CEO Tim Sweeney 在 X（原 Twitter）上对苹果的「合规表演」表示了批评。游戏制作人 Ukyo 也指出了日本中小开发者目前最明智的做法，或许是等待日本通过法院判例以及公平贸易委员会的执法行动来完善法律，弥补现有漏洞。

事实上，当苹果一次次用更复杂的规则、更精细的收费结构，去「消解」监管和判决的初衷后，监管也逐渐意识到一个现实问题：比起苹果的「合规行为」，更应该关注新规的「实质效果」。

在美国，Epic 案中法院要求不得阻止开发者引导用户使用外部支付，苹果形式上照做，却通过高达 27% 的外链佣金、显眼的安全警示、冗长的跳转流程，把「可以引导」变成了几乎没人愿意用。法官 Yvonne Gonzalez Rogers 指出，「苹果试图保留一条价值数十亿美元的收入来源，明目张胆地无视本法庭的禁令。」

为此，加州地方法院在 2025 年 4 月进一步裁定，勒令苹果必须在 21 天内放开第三方支付，不得阻止开发者引导使用第三方支付，且必须 0 抽成。于是到了 5 月，《堡垒之夜》重新上架美区 Appe Store，Spotify 等一众应用在 iOS 陆续支持跳转官网订阅，才真正走出 App Store 的支付闭环。

![](https://pics1.baidu.com/feed/b219ebc4b74543a95ba88f00c0e08d93bb011457.jpeg@f_auto?token=c11079f858845a42118aebef103c92d8)

《数字市场法》生效后，欧盟也迅速把监管重心放在执行结果上，开发者是否能顺畅引导用户、第三方支付是否真的可用、侧载和第三方商店是否被附加了不必要的障碍。在实行 3 个月后，欧盟就率先针对苹果发布了一份调查报告，指出苹果新规的不合规，并以阻碍开发者引导用户选择替代支付渠道为由，对苹果处以 5 亿欧元罚款，在整改前还面临每日最高 5000 万欧元的追加处罚。

在欧盟的多次处罚和整改要求下，苹果尽管一边在上诉中表示欧委会的决定超出了法案的要求，但还是一边重新修订了 App Store 条款，将延用全套苹果服务的「苹果税」抽成从 30%降至 20%。但采用分级收费制（主要针对采用第三方支付甚至应用商店）的新规仍然被苹果设计得复杂难懂，就连获得苹果设计奖的 Flighty 开发者 Ryan Jones 都放弃了理解新规，果粉如 John Gruber 也无法否认。

![](https://pics1.baidu.com/feed/21a4462309f790528b7a3625d304d0db7acbd548.jpeg@f_auto?token=074e6943d7e233351c411f34a9445fec)

可以预见的是，欧盟与苹果的博弈升级还在继续。相比之下，英国的集体诉讼也代表的是另一种层面的博弈升级，它绕开了「平台规则合理与否」「技术实现复杂度」这些容易被消解的争论，直接从结果出发提问：

在缺乏选择的前提下，消费者是否为苹果税买了单？

英国法院在去年 10 月的裁决就表明了观点，判决苹果应该支付英国消费者过去十年（2015-2024）在 iPhone、iPad 上因为「苹果税」多支付的 15 亿英镑。一旦这个决定最终执行，苹果面对的就不再只是整改成本，而是整个市场层面的赔偿风险，同时也会影响全球各地针对「苹果税」的诉讼，包括 2025 年 10 月国内消费者针对「苹果税」向国家市场监督管理总局提起的反垄断投诉。

而从美国、欧洲到日本，会发现一个越来越清晰的共识正在形成——不能指望苹果主动让步，也不能指望一次判决或一部法律一劳永逸。苹果会不断测试规则边界，用技术实现、条款设计和费用结构，把监管压力转化为可计算的成本，监管如果停留在合规行为层面，也很容易通过新的规则设计一次次「架空」。

iPhone 中国用户，不该交全球最高「苹果税」
尽管过去几年「苹果税」的高墙不断松动，但中国用户和开发者仍然面临全球最高比例的「苹果税」。据 Sensor Tower 数据，仅 2023 年「苹果税」全球收入就达到约 1608 亿元人民币，中国用户和开发者就「贡献」了约 482 亿元，不管是订阅流媒体会员，还是抖音、B 站的打赏充电，都在无形之间交了一笔「苹果税」。

482 亿元什么概念？相当于多买了 535.6 万台售价 8999 元的 iPhone 17 Pro，是阿里巴巴最新一季净利润（206.1 亿元）的两倍还多，接近 2025 年中国电影总票房（518.亿元）。这还只是中国市场一年的「苹果税」，而据苹果公布的官方报告，2024 年中国市场更是以 5390 亿美元的规模成为 App Store 生态最大的区域市场。

但贡献了 App Store 全球最大规模的中国市场，不该交着全球最高比例的「苹果税」。如果苹果税出现实质性下调，最直接的受益者并不只是开发者，而是数以亿计的 iPhone 用户——订阅可以更便宜，数字内容可以更透明，竞争也可以更充分。这也是为什么，围绕苹果降税的民间呼声始终不低。

问题在于，指望苹果主动让利，几乎不现实。从美国、欧盟、日本到英国的经验已经反复证明：苹果不会在核心利益上轻易让步。即便面对法规，它也会尽可能用技术细节和条款设计对冲冲击，把变化控制在可计算的范围内。

这恰恰也给国内市场提供了清晰的参照。有效的博弈，从来不是一句「降到多少」，而是多管齐下：通过立法明确哪些行为不可再被容忍；通过行政执法，把处罚与整改效果绑定，而不是一次性了结；通过公司主体诉讼和消费者维权，把问题从平台规则拉回到市场结果。同时，监管的关注点也需要从行为的合规，转向实质的结果。

归根结底，「苹果税」不是一道简单的算术题，也不可能一刀切解决。苹果不太可能轻易低头，监管也需要持续投入耐心和决心。但只有当博弈真正开始围绕实质效果展开，当规则不再容易被架空，中国 iPhone 用户，才有机会摆脱全球最高苹果税的现状。(来源：钛媒体APP)

## 提案


## Swift论坛
### 1、提案：为单参数数组和字典初始化器支持尾随闭包语法

作者：Tony Allevato ｜ 发布日期：2025 年 12 月 22 日
[阅读原帖](https://forums.swift.org/t/support-trailing-closure-syntax-for-single-argument-array-and-dictionary-initializers/83900 "Support trailing-closure syntax for single-argument Array and Dictionary initializers")

该提案讨论是否允许 Swift 为 **单参数的 `Array` 和 `Dictionary` 初始化器** 使用 **尾随闭包（trailing closure）语法**，从而提升构造集合时的可读性和一致性。

## 🔎 当前语法限制

在 Swift 中，如果你想基于表达式构造数组/字典，你需像这样写：

```swift
let arr = Array<Int>(repeating: 0, count: 5)
let dict = Dictionary<String, Int>(uniqueKeysWithValues: [
  ("a", 1), ("b", 2)
])
```

但当初始化器接收单一封闭的参数是可构造集合（例如用某种映射或生成器构造元素序列）时，现行语法无法使用尾随闭包，这看起来不够“ Swift 化”。提议希望增强语法，使得此类初始化器也支持更加简洁的尾随闭包写法。

## 💡 提案示例

设想如果支持尾随闭包，构造数组可以写成：

```swift
let arr = Array<String> {
  ["a", "b", "c"]
}
```

而不是：

```swift
let arr = Array<String>(["a", "b", "c"])
```

同样，对于字典：

```swift
let dict = Dictionary<String, Int> {
  ["a": 1, "b": 2]
}
```

其语义等价于现有的：

```swift
let dict = Dictionary<String, Int>(uniqueKeysWithValues: [
  ("a", 1), ("b", 2)
])
```

📌 **条件**：仅针对**单个参数**的初始化器 —— 即编译器无歧义地知道这个初始化器在接收一个集合值的情形。

## 🧠 讨论重点

### ✔️ 提升一致性和可读性

支持尾随闭包可让集合初始化更贴近 Swift 常见习惯，例如：

* SwiftUI 构建视图时广泛使用尾随闭包；
* Swift 标准库许多 API（如 `map`, `filter`）也使用尾随闭包表达操作逻辑。

让集合构造支持尾随闭包，能让语法更加统一、直观。

### ⚠️ 歧义与解析难点

讨论指出可能存在以下解析问题：

* 如果初始化器有多个参数，或有默认参数，则尾随闭包是否有歧义？
* 对于字典，有多个不同构造方式（例如 `uniqueKeysWithValues:`、`keys:` + `values:` 等），何种初始化器才可启用尾随闭包？
* 编译器是否容易区分尾随闭包表示的意图（是构造器参数，还是表达式块）？

若未来支持，语法或需限制于**无标签 / 单参数的明显构造场景**。

## 📌 社区观点

**支持的声音**：

* 有用户认为这将减少样板代码，使表达更加自然；
* 当生成集合逻辑较复杂时，尾随闭包可以提升可读性，并在多行构造器中表现更好；
* 与 SwiftUI 的使用习惯一致，有助于降低上下文切换认知成本。

**审慎或保留的意见**：

* 有人指出使用尾随闭包可能导致“看起来像函数体”而非构造值，影响可预测性；
* 字典初始化器重载较多，若允许尾随闭包，可能会出现不明确的候选集（compiler overload）；
* 有必要明确该语法仅适用于“一个无二义性参数”的初始化器。

## 🧩 小结

该提案旨在让 Swift 支持为 **单参数的 `Array` 和 `Dictionary` 初始化器** 使用尾随闭包语法，从而提升集合构造的可读性与一致性。它延续了 Swift 中尾随闭包的一贯设计风格，尤其与 SwiftUI 等 DSL 风格内容一致。不过在语义解析与重载分辨上仍需谨慎处理。

如果后续进入正式 SE 流程，建议关注以下：

* 语法边界 —— 哪些初始化器能启用尾随闭包？
* 编译器解析策略 —— 如何避免与现有语法冲突？
* 可读性 / 易用性评估 —— 何时使用更自然、何时可能造成困惑？

### 2、讨论：枚举一组元类型参数包（Enumerating a Parameter Pack of Metatype Instances）

作者：Slava Pestov ｜ 发布日期：2025 年 12 月 22 日
[阅读原帖](https://forums.swift.org/t/enumerating-a-parameter-pack-of-metatype-instances/83898 "Enumerating a Parameter Pack of Metatype Instances")

这篇帖子讨论了在 Swift 泛型与参数包（parameter packs）组合使用时，如何更好地 **遍历一组类型的元类型（metatype）**。目标是让开发者能够在编译时或运行时方便地对任意一组类型执行统一逻辑，从而增强参数包在元编程与泛型库实现中的表达能力。

## 🔎 核心问题

Swift 当前支持类型参数包（parameter packs），允许泛型接受任意数量的类型参数，例如：

```swift
func foo<T...>() { … }
```

在某些场景下，你可能会有一个类型参数包的元类型集合（如 `T.self...`），并希望对其中的每个类型执行某些操作：

```swift
func doSomethingWithTypes<T...>(_: T.Type...) {
  // 想枚举参数包中的每个元类型
}
```

但目前 Swift 对这种“批量处理元类型”的语义支持较弱，无法直接在单一循环或表达式内遍历参数包中的所有 `T.self` 项。

## 🧠 讨论内容与示例设想

帖子提出了几个关键思路与讨论点：

### 1）显式遍历参数包中的类型

一种设想是有更简洁的语法来迭代元类型参数包，例如：

```swift
for type in typesOf[T...] {
    …
}
```

使得可以在运行时依次处理 `T0.self`, `T1.self`, … 等类型。

### 2）结合宏或泛型构造

讨论中提到，参数包遍历可能结合宏系统实现更丰富的编译时代码生成，但也有人指出，在没有宏的情况下，能否仅依靠类型系统与泛型展开（pack expansion）进行静态遍历仍然值得探索。

## 📌 核心关注点

* **元类型与参数包的语义组合**
  当前 Swift 的泛型参数包只能在特定上下文用扩展语法展开（例如作为函数参数列表、元组成员、函数返回多个值等），但无法直接把它抽象成可迭代的集合来使用。因此想要通用处理参数包中的 `Type.self` 仍显繁琐。

* **循环 / 迭代语法缺失**
  将多个 `T.self` 统一处理时，语言层面没有提供循环语义或内建机制展开参数包。通常需要手动递归定义辅助函数或宏来辅助实现。

* **宏系统或编译器扩展可能解决**
  有人认为 Swift 的宏机制可以协助解决这类元编程难题，即在编译期根据参数包自动展开代码，而非在运行时动态处理。这也是 Swift 宏未来发展方向之一。

## 🧩 小结

这篇讨论重点聚焦于 Swift 泛型与参数包在处理 **一组元类型（metatype）** 时的表达力瓶颈。当前语言不直接支持“将参数包视为可迭代集合并统一遍历其元类型”的语法或语义，因此讨论集中在以下方向：

* 是否需要语言级别为类型参数包提供更简洁的枚举 / 遍历机制；
* 是否结合宏系统在编译期间展开参数包，从而支持更强的元编程能力；
* 如何在不引入宏的情况下，通过现有类型系统表达类似能力。

对那些在泛型库、反射 / 序列化工具或元编程中需要批量处理类型元数据的场景而言，这类能力将显著简化代码与提升表达力。虽然目前仍处于讨论探索阶段，但这反映了社区对 Swift 参数包与元类型组合语义的进一步追求。

### 3、提案：在更多位置支持 `#warning` 提示

作者：Xiaodi Wu ｜ 发布日期：2025 年 12 月 22 日
[阅读原帖](https://forums.swift.org/t/allow-warning-in-more-places/83889 "Allow `#warning` in more places")

这篇帖子提出一个语法改进建议：让 Swift 的 `#warning` 指令 **可以在更多上下文中有效使用**，从而提高开发者标注临时代码、提醒注意事项或突出待办问题（TODO）的可见性。

## 🔎 当前限制

Swift 已支持 `#warning("message")`，用于在编译时发出自定义警告；但目前它只能用于 **文件顶层、类型/函数声明外的逻辑**。如果放在某些上下文（例如 `if`, `switch`, `do` 块或局部作用域）中，则编译器报错提示其无法在该处使用。

例如：

```swift
func f() {
    #warning("this code needs review") // ❌ 无效（当前不允许）
}
```

在这种情况下，开发者不得不将警告放在函数外，或用注释代替，无法在真正对应逻辑的位置发出编译时提醒。

## 📌 提案内容

* 允许 `#warning` 在更多位置有效，包括但不限于：

  * 局部作用域中（如函数体内）
  * 条件语句块内（如 `if` / `switch` / `guard`）
  * 循环块内（如 `for` / `while`）
  * `do` 代码块或更细粒度控制流上下文

* 目标效果是让编译器在更多地方都能发出自定义警告，而不是只能在全局范围或类型级别发出。

## 🧠 社区讨论要点

**支持观点：**

* 很多开发者认为这将提升代码可维护性：

  * 当某段逻辑需要审查、修复或有明显欠缺时，可直接在该逻辑内部标注 `#warning`。
  * 在大型代码库或复杂流程中，这种警告能更直观地提醒代码审查者（Instead of TODO 注释被忽略）。

* 有人提到这是传统 C/Objective-C 中常见的做法，Swift 支持更广泛的警告位置有助于“提醒更贴近代码位置”。

**审慎意见：**

* 核心开发者提醒需注意语义一致性：

  * 如果允许在局部作用域发出编译时警告，应明确其语义何时触发。
  * `#warning` 本质上是编译器机制，而不是注释，因此它的激活位置若过多可能产生噪音；需要考虑是否影响每日开发体验。

* 讨论也涉及 IDE 体验：

  * 如果 `#warning` 在局部位置出现，Xcode 编译警告面板、导航会如何显示？
  * 是否需要在 IDE 层做特殊处理，使局部警告也易于查找？

## 🧩 小结

这个提案旨在扩展 Swift 的 `#warning` 能力，让开发者可以更自由地在**任何代码块或局部作用域中发出编译时警告提示**，而不是受限于文件顶层或声明外。其好处是：

* 可以更精确地标注需要重视的地方
* 提高警告提示的可见性与语义关联性
* 减少丢失注释 TODO/警告的风险

不过，为了不会过度噪声化编译器输出，需要在语义定义与 IDE 支持上做进一步考量。目前该想法仍处于讨论阶段，并未形成正式提案。

### 4、讨论：让 `Dictionary.mapValues(_:)` 获得关联键（Key）信息

作者：taylorswift ｜ 发布日期：2026 年 1 月 1 日
[阅读原帖](https://forums.swift.org/t/giving-dictionary-mapvalues-access-to-the-associated-key/83904 "Giving Dictionary.mapValues(_:) access to the associated key")

这条论坛讨论聚焦在 Swift 标准库的 `Dictionary.mapValues(_:)` 方法上：**当前它只接受一个只带 `Value` 的转换闭包，但有时我们希望在映射值时也能访问对应的键（Key）**，以便根据键的内容决定新值。社区正在探讨是否需要改进这一 API。

## 🔎 现状与问题

当前 Swift 的 `Dictionary.mapValues(_:)` 提供的是一个只接收值的闭包，例如：

```swift
let newDict = oldDict.mapValues { value in
    // 只能访问 value，没法看到 key
}
```

若想在映射时同时用到键，就只能使用下面这些笨拙或低效的模式：

```swift
let new: [Key: NewValue] = .init(
    uniqueKeysWithValues: old.lazy.map { (key, value) in
        (key, transform(id: key, payload: value))
    }
)

let new2: [Key: NewValue] = old.reduce(into: [:]) {
    $0[$1.key] = transform(id: $1.key, payload: $1.value)
}
```

但这种写法**会对字典重新做哈希**并重新构造存储 —— 性能不如标准库现有的 `mapValues(_:)` 实现。([Swift Forums][1])

## 🧠 讨论亮点

### 性能与功能兼顾的需求

* 标准库内部 `mapValues(_:)` 的实现**不需要重新哈希**，因为它沿用原字典的存储结构，只替换值部分。但现有 API 不把键传给闭包，导致开发者无法直接写出既高效又能用到键的映射逻辑。
* 讨论认为：若能为 `mapValues` 添加新重载，让闭包接收 `(Key, Value)`，则可以避免“笨拙模式”的性能损失。例如：

  ```swift
  extension Dictionary {
      @inlinable
      func mapValues<T>(
          _ transform: (Key, Value) throws -> T
      ) rethrows -> Dictionary<Key, T>
  }
  ```

  这样的重载既与现有的 `mapValues { value in … }` 保持兼容，又能让用户在闭包里访问 key。([Swift Forums][2])

### 社区讨论

* 有人指出这种 API 在实际项目中非常常见，而且历史上就有人提出对带键 context 的 map 函数的需求。([Swift Forums][1])
* 现有的实现模式（如 `uniqueKeysWithValues` 或 `reduce(into:)`）由于需要重新插入键-值对，其性能不如库内部优化过的 `mapValues`。([Swift Forums][1])
* 讨论还举出为 `OrderedDictionary`（来自 swift-collections）也增加类似支持的潜在好处，因为那里的键序信息更多。([Swift Forums][1])

### 现有 workaround

* 若新值类型与旧值类型一致，可以用更低级方式在原字典上原地修改：

  ```swift
  var dict = old
  for index in dict.indices {
      let (key, value) = dict[index]
      dict.values[index] = transform(id: key, payload: value)
  }
  ```

  但这种方式不适用于改变值类型的情景。

## 🧩 小结

目前社区正在探讨增强 `Dictionary.mapValues(_:)` 的能力，使其在映射值时 **同时提供对应的键作为参数**，从而提升 API 的表达力和性能效率。现有的方案虽能手动实现，但都要付出哈希或结构重建的性能代价。若未来标准库采纳这样的重载，开发者就能更加直接、安全地基于键值对进行高效转换。

### 5、介绍《使用 Swift 编程》一书（An Introduction to Programming Using Swift）

作者：hryde ｜ 发布日期：2026 年 1 月 1 日
[阅读原帖](https://forums.swift.org/t/an-introduction-to-programming-using-swift/83901 "An Introduction to Programming Using Swift")

这篇 Community Showcase 帖子介绍了 **《An Introduction to Programming Using Swift》** 这本面向初学者的 Swift 编程教材的最新进展，并发布了其 **Beta 0.5.1 版本**，旨在帮助新人系统学习 Swift 编程。([Swift Forums][1])

**主要内容：**

* 《An Introduction to Programming Using Swift》最早由作者在 Swift 2 时代开始编写，后随着语言演进不断重写，当前在 **Swift 6.0/6.x 环境下重新整理后进入 beta 发布阶段**。([Swift Forums][1])
* 该书体量庞大，超过 **2,600+ 页**，包括 **25 章正文 + 12 个附录**。📘 目前 Beta 版 **0.5.1 已包含校对完成的第 1–17 章**，涵盖对初学者最重要的语言基础和核心概念部分，其余章节仍是草稿状态。([Swift Forums][1])
* 作者发布此 beta 版本旨在 **征求社区反馈**，特别是第一部分（前 17 章），这些内容覆盖了多数入门者在学习 Swift 语言时最需要掌握的知识。([Swift Forums][1])

**章节范围示例（部分）：**

* Swift 基本语法、数据类型与语句
* 条件控制与循环
* 函数、闭包、错误处理
* 集合类型（数组、字典、集合）
* 字符串与字符处理
* 结构体、类、枚举、协议与泛型
* 错误处理与先进类型系统机制
* 附录：标准库引用、集合方法、模式匹配等内容概览 ([Swift Forums][1])

**发行形式：**

该书 beta 版提供多种格式供选择：

* PDF（推荐，可读性最佳）
* EPUB3（适合 Apple Books）
* AZW3（Kindle，渲染效果稍弱）

### 🧩 小结

这本书是一个**面向初学者的大部头教材**，目标是用 Swift 系统讲解编程基础与进阶话题，内容从基本语法到复杂类型系统涵盖广泛。尽管还在 beta 阶段，但其第一部分已足够作为 Swift 新手入门和巩固基础的学习材料。作者鼓励读者参与反馈与校对，为未来正式版打下基础。([Swift Forums][1])

## 推荐博文

以下三篇文章非常值得一读，适合本周“提升技能 + 开阔思路”：

[深入探索 Android 版 Swift SDK](https://www.swift.org/blog/exploring-the-swift-sdk-for-android/ "深入探索 Android 版 Swift SDK ")

**摘要：** 这篇官方文档介绍了 Swift 在 Android 平台上的开发现状与未来展望。它从一个已投入生产实践多年的社区项目谈起，如今正逐步演变为拥有官方工作组支持、工具链日益完善的跨平台开发方案。文中不仅探讨了其技术实现，如通过原生编译和 Java 互操作来平衡性能与安全，也展示了多个成功商业应用的真实案例。工作组正着力提升开发体验，并明确了共享核心业务逻辑的跨平台定位，同时积极邀请社区贡献。全文描绘了一幅Swift生态从 iOS 向 Android 稳健扩展、从社区热情走向成熟工业化应用的图景。

[Swift Array的写时复制](https://juejin.cn/post/7585406229150629926/ "Swift Array的写时复制")

**摘要：**  这篇文章以直观的实验方式，探讨了 Swift 中 Array（数组）作为值类型时其核心特性“写时复制”的具体表现，并对比了数组内元素分别为引用类型与值类型时这一机制的不同影响。

文章的核心在于阐明一个关键区别：当数组存储引用类型（如自定义类对象）时，“写时复制”机制复制的仅仅是指向这些对象的指针，而非对象本身。因此，即使在对数组副本进行结构性修改（如增删元素）触发缓冲区复制后，原数组与副本数组中对应的元素仍指向内存中的同一个对象，修改对象的属性会相互影响。

而当数组存储值类型（如字符串、整数）时，“写时复制”机制则表现得更为彻底。一旦触发复制，不仅会开辟新的缓冲区，缓冲区中存储的每个值类型元素本身也会被复制一份，从而使得原数组与副本在修改后完全独立，互不影响。

[swift 带有关联类型的协议不可以做类型？](https://juejin.cn/post/7584730308752654386/ "swift 带有关联类型的协议不可以做类型？")

**摘要：**  这篇文章探讨了 Swift 中一个让许多开发者感到困惑的类型系统特性。它始于一个常见的说法——带有关联类型的协议不能作为独立类型使用——并通过代码实验揭示了这一论断在较新的 Swift 版本中已不再完全准确。

文章的核心在于区分“声明”与“使用”。实验表明，将变量声明为这种协议的类型是允许的，真正的限制出现在调用其方法时。这种限制的根源在于编译器采用的“类型擦除”机制：当协议被当作一个抽象类型持有时，其关联类型的具体信息在编译期被有意隐藏了，以保证统一性。这使得编译器能够安全地处理方法返回值，却无法在调用时验证传入的参数类型是否匹配。


## 关于我们

**Swift 社区** 是由 Swift 爱好者共同维护的技术组织，主要通过微信公众号运营。

我们专注于 **Swift 实战、SwiftUI、Swift 基础** 三大方向，每周为你带来精选内容与最新生态资讯。

**关注公众号：「Swift社区」**
后台回复 “进群” 即可加入开发者交流圈。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
