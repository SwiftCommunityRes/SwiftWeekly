## 前言

**本期是 Swift 编辑组自主整理周报的第八十六期**，每个模块已初步成型。各位读者如果有好的提议，欢迎在文末留言。

Swift 周报在 [GitHub 开源](https://github.com/SwiftCommunityRes/SwiftWeekly "SwiftWeekly")，欢迎提交 issue，投稿或推荐内容。目前计划每两周周一发布，欢迎志同道合的朋友一起加入周报整理。

神之巅，傲世间，有我iPhone便有天。‌光之速，耀万目，一方星宇破云雾。👊👊👊

> **周报精选**
>
> 新闻和社区：准备探索新一代 iPhone、Apple Watch 与 AirPods
> 
> 提案：环境受限的共享库提案正在审查
> 
> Swift 论坛：讨论 @unknown default 的用途与新规则
>
> 推荐博文：Swift 6.0 协议扩展：解锁协议新特性，写出更优雅、更高效的代码
>

## 话题讨论

有网友说：OPPO模仿苹果手机外观设计，小米模仿苹果手机型号，华为模仿苹果手机价格，vivo模仿苹果手机的功能生态。**那么你觉得为什么这么多品牌都在模仿苹果呢？**

1. 为了适配大多数用户的手机使用习惯。
2. 为了蹭苹果手机的热度和流量。
3. 为了减少设计和科研成本。
4. 苹果手机早已成为手机精英领域的标准，不模仿苹果的那些设计都被淘汰啦。
5. 经过这么多年的设计演化和淘汰，能保留下来的就那么几种，设计趋同是无可避免的。

## 新闻和社区  

### 消息称苹果计划在中国台湾地区试产折叠屏iPhone，手机明年推出

2023 年 9 月 18 日

据《日经亚洲》报道，苹果公司正与中国台湾地区的供应商洽谈，计划在当地建立传闻中折叠屏 iPhone 的测试生产中心。

![](https://files.mdnice.com/user/47553/74d70aed-d24a-408b-8424-83ba1b16ed79.png)

该媒体援引消息人士的话称，苹果有意搭建一条小型试点生产线，用于“验证设备性能、微调参数及制造流程”，为其折叠屏 iPhone 的生产做准备。这款机型预计将于明年（2026 年）推出。

报道指出，苹果的长期计划是在印度复制这一试点生产线，进而在印度大规模生产这款新旗舰智能手机，确保产品顺利推出。不过，初步方案似乎并非毫无阻碍。报道中提到：

两位消息人士透露，苹果的供应商已看中中国台湾地区北部某城市的一块土地，计划用于建设上述试点生产线，但他们同时表示，该计划尚未最终确定，仍有可能发生变动。此外，他们还指出中国台湾地区目前面临一些挑战，例如，即便只是建设一条试点生产线，也需要约 1000 名操作人员，而当地在 iPhone 生产所需的土地和劳动力资源方面均存在局限。

苹果已向多家供应商表示，预计折叠屏机型的推出将带动整体 iPhone 需求增长，其中包括非折叠屏机型。《日经亚洲》的消息人士称，苹果目标在 2026 年推出的下一系列 iPhone 中生产约 9500 万台，较 2025 年的手机总出货量增长 10%，而苹果认为，推出这款备受期待的折叠屏机型将有助于实现这一目标。

目前已有多名消息人士证实，苹果计划在 2026 年推出其首款折叠屏 iPhone，该设备将归入 iPhone 18 系列。例如，行业分析师郭明錤表示，苹果计划于明年推出折叠屏 iPhone，随后将在 2028 年推出折叠屏 iPad。

郭明錤还详细披露了这款折叠屏 iPhone 的相关信息：该机型将采用书本式折叠设计，配备约 7.8 英寸的内屏和 5.5 英寸的外屏，定价介于 2000 至 2500 美元（IT之家注：现汇率约合 14200 至 17749 元人民币）之间。为节省折叠设计下的内部空间，苹果预计将舍弃 Face ID 面部识别功能，转而采用集成在侧边按键中的 Touch ID 指纹识别技术。此前，苹果已在 iPad Air 和 iPad mini 机型上采用过侧边按键集成 Touch ID 的设计。

在摄像头配置方面，郭明錤表示，这款折叠屏 iPhone 预计将搭载双后置摄像头，同时配备一枚前置摄像头，可在手机折叠和展开两种状态下使用。

彭博社记者马克・古尔曼也表示，预计该设备将于明年秋季推出。(来源：IT之家)

### iPhone 17发布前夕 苹果(AAPL.US)在华手机销量同比下降6%

2025 年 9 月 17 日

智通财经 APP 获悉，根据 Counterpoint Research 的数据，在 iPhone 17 发布前的几周里，苹果( AAPL.US )在中国的智能手机销量同比下降了 6%，这一数字比以往新产品发布前的降幅更大。

这家美国科技巨头并非唯一一家面临夏季低迷的公司。其竞争对手小米( 01810 )、Vivo 和荣耀在第三季度前八周也出现了销量下滑的情况。

数据显示，第三季度前八周，中国智能手机销量同比下降 2%。与此同时，华为持续的产品组合拓展助力其销量保持了正增长态势。

Counterpoint 预计，中国智能手机市场在整个第三季度将出现小幅负增长，2025 年全年将持平。

部分 Seeking Alpha 分析师表示，苹果最新款 iPhone 17 没有实质意义的创新，仅提供了些微的更新，并不具备引发大规模换机热潮的催化剂。

截至发稿，苹果盘前跌 0.11%。（来源：和讯财经）

### 准备探索新一代 iPhone、Apple Watch 与 AirPods

2025 年 9 月 11 日

9月19日起，顾客可预购最新 iPhone 机型和全新配件。

![](https://www.apple.com.cn/newsroom/cn/images/2025/09/get-ready-to-discover-the-next-generation-of-iphone-apple%C2%A0watch-and-airpods/Apple-September-2025-new-product-lineups_big.jpg.large_2x.jpg)

周五晚 8 点起，顾客可通过 apple.com.cn 和 Apple Store app 预购并升级至突破性 iPhone 17、iPhone 17 Pro 和 iPhone 17 Pro Max。史上最薄 iPhone——拥有专业级性能的 iPhone Air 将于晚些时候发售。

全部四款机型均首次配备 Center Stage 前置摄像头，将自拍体验提升至全新境界，且搭载最新一代芯片，性能强劲且经久耐用。精美的新设计更加坚固耐用，抗刮划能力较上代机型提升至 3 倍。新一代 iPhone 运行 iOS 26，这是 Apple 最新发布的软件平台，采用基于 Liquid Glass 的优美新设计，带来一系列激动人心的新功能和特性，为用户提供更个性、更强大、更智能的体验。

Apple Watch Series 11、Apple Watch Ultra 3、Apple Watch SE 3 和 AirPods Pro 3 现已通过 apple.com.cn 和 Apple Store app 接受预购。上述新产品和新一代 iPhone 机型都将于 9 月 19 日（周五）起在 Apple Store 零售店正式发售。

来 Apple，省更多
升级至新 iPhone 的体验现在更加轻松、更加智能。顾客可利用 Apple Trade In 换购计划、iPhone 年年焕新计划和分期付款选项，享受优惠购物体验。同时，iPhone 比其他智能手机更加保值，在折抵当前或旧设备时价值更高。

顾客可折抵符合条件的 Apple 设备（包括 iPhone、Mac、iPad 或 Apple Watch）来换购 iPhone 17、iPhone Air、iPhone 17 Pro 或 iPhone 17 Pro Max。使用 iPhone 13 或后续机型换购时，顾客可享预计为 RMB 1,100 到 RMB 6,550 的折抵优惠。

全新产品阵容亮相
iPhone 17 满载用户常用功能，包括更宽大明亮的 ProMotion 显示屏、满足全天所需的电池续航、快速充电、卓越的 4800 万像素融合式双摄系统和 Center Stage 前置摄像头。全新 iPhone Air 采用极致轻薄的设计，比以往所有机型更加持久耐用，且具备专业级性能，前后均配备先进摄像头系统，且具备满足全天所需的出色电池续航1。搭载 A19 Pro 芯片、采用全新设计的 iPhone 17 Pro 与 iPhone 17 Pro Max 是迄今最强大的 Pro 机型，具备 iPhone 有史以来最强的性能、摄像头系统和电池续航。

![](https://www.apple.com.cn/newsroom/images/2025/09/get-ready-to-discover-the-next-generation-of-iphone-apple-watch-and-airpods/article/Apple-iPhone-17-Pro-cosmic-orange_inline.jpg.large_2x.jpg)

Apple Watch 推出全新产品阵容，为全球畅销的腕表带来诸多强大新功能。Apple Watch Series 11 堪称终极健康与健身良伴，推出新功能睡眠评分，电池续航时间最长可达 24 小时，满足用户日夜佩戴需求。Apple Watch SE 3 的性能与功能均大幅升级，配备全天候显示屏，具备手腕温度感应等功能，更加物超所值。终极运动与冒险腕表 Apple Watch Ultra 3 提供最长达 42 小时电池续航时间，且配备 Apple Watch 迄今最大显示屏。

![](https://www.apple.com.cn/newsroom/images/2025/09/get-ready-to-discover-the-next-generation-of-iphone-apple-watch-and-airpods/article/Apple-Watch-Ultra-3_inline.jpg.large_2x.jpg)

AirPods Pro 3 具备妙不可言的音质和颠覆性入耳式主动降噪（ANC）功能，降噪能力较初代 AirPods Pro 提升至最多 4 倍。全新设计使 AirPods Pro 3 的贴合度更高，在进行跑步、高强度间歇训练和瑜伽等活动时，入耳稳固性更佳。AirPods Pro 3 首次为用户带来体能训练期间的心率监测功能，并可通过 iPhone 健身 app 的新体验跟测 50 种体能训练类型。

![](https://www.apple.com.cn/newsroom/images/2025/09/get-ready-to-discover-the-next-generation-of-iphone-apple-watch-and-airpods/article/Apple-AirPods-Pro-3_inline.jpg.large_2x.jpg)

直接从 Apple 购物，享受诸多福利
选择直接从 Apple 购物，顾客可享受来自 Apple Specialist 专家的个性化支持与新的折抵换购优惠，并通过 Today at Apple 免费课程了解如何全面利用自己的设备。Apple 还将推出一系列新课程和升级课程，包括“轻松入门：iOS 26 新功能一览”和“认识 iPhone 17”等，帮助用户通过更多方式了解和利用最新 Apple 产品。

对最新 AirPods 系列产品感兴趣的顾客可在新设备上混搭镌刻表情符号、文字和数字，喜欢 Apple Watch 的顾客则可选择多种表壳材质、外观、表带样式和色彩，表达个性风格。
Apple 在多个市场为用户提供当日和次日送达服务，此外用户也可到各地 Apple Store 零售店自行取货。

![](https://www.apple.com.cn/newsroom/images/2025/09/get-ready-to-discover-the-next-generation-of-iphone-apple-watch-and-airpods/article/Apple-Pickup-counter_inline.jpg.large_2x.jpg)

中国大陆地区推出更多购物方式
今年早些时候，Apple 在安徽省的首家 Apple Store 零售店——Apple 合肥万象城零售店与其在深圳的第三家零售店——Apple 前海壹方城零售店相继开幕。目前，Apple 在大中华区拥有 58 家零售店，数千名团队成员为顾客提供卓越服务、打造难忘体验。

中国大陆的顾客除了直接通过 Apple 零售渠道购物，还可通过多种方式探索和购买 Apple 产品、获取专业协助、下单预购等。

天猫 Apple Store 官方旗舰店：在天猫 Apple Store 官方旗舰店，顾客可探索 Apple 全部产品，体验与 Apple 零售相同的卓越服务和功能，包括 Apple Specialist 专家的协助、分期付款选项、免费送货等等。

Apple Store 官方在线商店微信小程序：顾客可通过微信小程序探索最新 Apple 产品与体验，并享受 Apple Trade In 换购计划、iPhone 年年焕新计划、免费镌刻等丰富服务和体验。小程序的全部订单均可享受免费送货。

抖音 Apple Store 官方旗舰店：抖音 Apple Store 官方旗舰店上个月刚刚上线，可供用户探索与购买最新 Apple 产品，并享受 Apple 团队成员提供的卓越服务。用户还可观看短视频，获取 Apple Creative 培训师提供的实用妙招，探索最新款 iPhone、iPad、Mac 和 Apple Watch 系列产品激动人心的功能。

Apple 持续探索创新方式，联结中国与世界各地的多元社区。通过拓展零售方式和优化在线购物选项，Apple 致力于为顾客提供顺畅充实的购物体验。无论光顾实体零售店、在线购物还是通过天猫、微信小程序和抖音等平台购物，顾客都可安享 Apple 声誉卓著的高品质服务与支持。

## 提案

### 正在审查的提案

[SE-0490](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0490-environment-constrained-shared-libraries.md "SE-0490") **环境受限的共享库** 提案正在审查。

SwiftPM 目前不支持 Linux 上的非系统二进制库依赖项。该提案增加了对环境受限共享库的支持，这是一种跨机器共享的动态库，无需重新编译和重新部署这些计算机上运行的所有应用程序即可升级。我们将通过现有的 `.artifactbundle` 格式分发受环境约束的共享库。

[SE-0491](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0491-module-selectors.md "SE-0491") **用于名称消歧义的模块选择器** 提案正在审查。

我们建议扩展 Swift 的语法，以便无论何时用源代码编写标识符来引用声明，它都可以将其作为 `ModuleName::` 前缀，以消除声明预计来自哪个模块的歧义。此语法将为解决几种类型的名称歧义和冲突提供一种方法。

## Swift论坛

1、提议[模块选择器用于名称消歧义](https://forums.swift.org/t/se-0491-module-selectors-for-name-disambiguation/82124 "模块选择器用于名称消歧义")

该提案进入评论审查阶段（Review）（2025 年 9 月 13 日至 9 月 26 日）。其目标是为 Swift 引入一种新的语法机制，用来在存在模块或类型名冲突时帮助消歧。例如，当多个模块导出同名类型或声明时，通过指明模块来明确引用的是哪个定义。

提案核心内容

* 新语法使用 `Module::Name` 的形式，即在名字之前加上模块选择器（module selector） Module::，例如：

```swift
_ = RocketEngine::Fuel()
```

表示明确取用 RocketEngine 模块里的 Fuel，绕开作用域中其他同名类型。

* 提案还提供工具链支持，启用编译标志 -enable-experimental-feature ModuleSelector 后使用这个特性。提供给 macOS、Linux、Windows 等环境使用。
* 在候选名称查找（name lookup）中，当使用模块选择器时，只有声明在该模块中或被该模块 re-export 的声明会被视为候选。这样可确保选择器的精确性。

社区反馈与争议点

* 多数人支持该改动，认为冲突情况在实际项目里确实常见，“名称遮蔽”（name shadowing）与模块导出问题会带来维护成本。
* 对 :: 语法的接受度较高，有人觉得它类似 C++ 的模块限定符，用起来直观。也有人觉得 :: 在 Swift 感觉稍微“别扭”（awkward），尤其是它放在成员类型或成员路径中的优先级／解析顺序（precedence and parsing）问题。
* 有人建议提供备用语法或更明确的标记，例如用类似 `#module(ModuleName).Member` 的形式，但被认为过于冗长或语法结构复杂。
* 对靶向成员类型中的模块限定（qualified member types）例如 `T.Foo::Bar` 的支持是否应被允许，是一个争议点。有反馈认为在泛型上下文中对成员类型做模块限定可能会引入混淆。
* 还有关文档工具与编码工具支持的问题，比如 DocC、接口文档、导出头文件、Swift interface 文件命名中如何处理带 :: 的名称，因为 :: 在某些文件系统或 URL 中可能不被允许或创建歧义。


优点 & 潜在风险

优点：

* 能明确开发者意图，避免命名冲突带来的编译或 API 混淆问题。
* 提高大型代码库中，跨模块引用类型时的可读性与维护性。
* 用户可从手写代码层面解决某些名称遮蔽问题，而不是依赖重构或导出策略。

风险 / 实现挑战：

* :: 的语法在某些上下文中解析优先级可能引起困惑，特别是与成员访问，泛型成员或关联类型混用时。
* 构建工具链、接口生成工具、文档生成、文件命名等需要兼容性处理。
* 语言设计保持简洁性与一致性的挑战：加入新的限定符号可能让语法曲线稍稍上升。

总结

SE-0491 是一个实用性很强的提案，旨在解决 Swift 生态中命名冲突、模块导出与类型遮蔽带来的维护困难。提案的语法形式 Module::Name 被多数社区成员看好，接受度较高。当前讨论的重点在于语法细节（优先级、解析）、与现有语言特性（泛型、成员类型等）的兼容性，以及工具链/文档/接口展示等侧边问题。


2、提议[非可复制值的部分重新初始化](https://forums.swift.org/t/partial-reinitialization-of-noncopyable-values/82153 "非可复制值的部分重新初始化")

提案内容

* 提案由 Joe Groff 发起，目标是为 Swift 中的 非可复制类型（noncopyable types） 引入一个新能力：在某些情况下，对其被部分消费（partial consumption）的字段进行重新赋值，从而使整个值变为“完整”（whole）状态。
* 背景是 SE-0429 已允许对非复制类型中的部分成员进行消费，也就是说可以对 struct/tuple/enum 的某些字段进行“消费”（例如调用消耗成员的 consuming 方法），但一旦某个字段被消费，对象整体就无法被包括该字段在内地恢复为完整状态，除非重建整个值。
* 提案示例中，假设有这样一个类型：

```swift
struct BufferedFile: ~Copyable {
  var file: File
  var buffer: Buffer
  consuming func takeBufferAndCloseFile() -> Buffer {
    file.close()
    return buffer
  }
}
```

在目前状态，如果 file 被消费（例如关闭），就不能仅通过对 file = newFile 来恢复，而必须重建整个 BufferedFile 实例。该提案希望允许这样的部分重初始化。
设计细节与限制

* 部分重新初始化只适用于 存储属性（stored properties），并且只能发生在类型定义所在模块，或者是 public 且标注 `@frozen` 的类型。对于未标注 `@frozen` 的公共类型，其存储布局可能未来变化，不能安全依赖。
* 在部分重新初始化之前，字段必须被消费（partial consumption）；在退出方法或 value 生命周期之前，这些被消费的字段要被重新赋值，才能保证类型状态恢复完整。否则会被视为错误。这样可以避免绕过类型的初始化器或析构器（deinit）带来的语义破坏。
* 对于具有自定义 deinit 的类型，此提案允许在部分消费之后仍然支持重新初始化，只要在值存活期间消费的字段被重新初始化。这样能让 deinit 在对象完全终结前仍然正常执行类型预期的行为。
* 提案不会改变现有语法行为，不会破坏源兼容性，也不会影响 ABI，因为只是新增行为，无需改变运行时类型布局。

社区反馈要点

* 很多同样使用非可复制类型的开发者表示这是他们“最缺失的功能之一”，能明显简化某些写法，减少样板和错误。
* 有人对 public 类型非 `@frozen` 的限制提出疑问，是否可能未来通过某种方式标记某些公共存储属性明确为“可被部分重新初始化”，即使类型本身不是 `@frozen`。
* 有用户关心这项功能是否适用于计算属性（computed properties）或只有 setter/或私有 setter /只读属性等情形，因为这些属性可能无法公开成为存储属性或可重写的字段。提案中对此类情况有明确限制，并非所有属性都能支持重初始化。

总结

这个提案在 Swift 的非可复制类型（noncopyable）系统中填补了一个用户体验上的重要空白：允许部分消费后的值通过赋值恢复完整性，而不是必须重建整个实例。它在 API 安全性、兼容性上都有较为谨慎的设计（限制于存储属性、@frozen 类型、模块边界等）。如果实现，它将提升非可复制类型的可用性与编程便利性。

如果你要写报告，我可以帮你列一些这个提案可能的风险或未来关注点，以便平衡视角。你要我加这些吗？

3、讨论[“真实安全 (reality-safe)”隔离模型中允许这种访问的可能性](https://forums.swift.org/t/finding-a-way-to-allow-this-in-reality-safe-isolation-violation/82145 "“真实安全 (reality-safe)”隔离模型中允许这种访问的可能性")

该帖由 Jeremy Bannister 发布于 2025 年 9 月中旬，讨论 Swift 并发隔离模型中一个被认为“不必要严格”的访问限制，以及社区是否可以允许在某些条件下越过该限制。

样例代码与问题

以下代码在 Swift 6.2 中不会编译：

```swift
actor Foo {
    let bar: Bar

    init() {
        self.bar = .init(constant: 7)
    }

    nonisolated var constant: Int {
        bar.constant // Error: Actor-isolated property 'bar' cannot be referenced from a nonisolated context
    }
}

class Bar {
    let constant: Int
    init(constant: Int) { self.constant = constant }
}
```

问题是：在一个 actor 类型中，bar 属性是 actor 隔离的；但 constant 只是读取一个不可变存储属性 (let constant)。作者觉得，如果整个访问路径都是不可变的（actor 的 let 存储 + Bar.constant 是 let），理论上这是安全的，所以希望允许这种访问，至少在类型是非公共（non-public）的情况下。

社区反馈与观点

* John McCall 回复说，他同意这种访问在这种情形下是安全的，只要 “整个访问路径都是不可变的”。也就是说，当 bar 是 let，而其类型 `Bar.constant` 也是 let，并且都不是可以被外部修改的情况，则允许可能没有安全问题。
* 对于公共类型（public types），有观点认为自动放宽这类访问可能引入未显式的承诺（promise），因为公共接口通常需要非常明确的隔离与可变性语义。非公共类型情况则不那么敏感。
* 有人提出变通方案，例如给 Bar 类型提供一个 Sendable 包装，或在类型中显式展示可安全地使用的不可变版本。也有提出为这种访问提供专门的语言标记或关键字，以便明确表明路径是不可变的，从而被编译器允许。

总结与可能演进

这个讨论暴露了 Swift 隔离模型中一个细节：即使整个路径是不可变的，actor 隔离规则目前不允许在 nonisolated 上访问 actor 中的 let 存储属性。对于许多开发者来说，这个限制在实际应用里显得过于保守。

如果语言未来演进，可能方向包括：

* 在非公开／模块内部的类型中，对完全不可变访问路径的允许；
* 引入标记／关键字以明确声明某个属性链是不可变的；
* 在语言规范或者编译器诊断中更好地说明为何这类访问被禁止，以及在什么情况下可以放宽。

4、讨论[Swift 中声明式编程未来方向的思考](https://forums.swift.org/t/thoughts-about-future-directions-for-declarative-programming-in-swift/82139 "Swift 中声明式编程未来方向的思考")

作者 Alexander Kozin 等在论坛中发起讨论：当前 SwiftUI 已经是一种声明式风格。问题是，未来 Swift（例如 Swift 7）是否会更“声明式”——甚至让更多语言特性（非仅 UI）都倾向声明式，或者提供类似的语法支持。

核心观点与社区反馈

* SwiftUI 的声明式风格被认为是函数式（functional）风格的一种体现，而 Swift 本身已有部分函数式特性，所以很多人认为可声明式的编程风格“不太可能被完全颠覆／重写”，但可以增强或扩展。
* 一个被频繁提及的方向是 referential transparency（引用透明性）：即让函数不依赖外部可变状态，纯粹地根据输入返回输出。有人认为这是声明式编程中非常重要、但当前 Swift 中支持不够的部分。
* “函数标色”（colouring functions / effect-typing）的建议也被多次提出。比如标记函数是否非确定性（nonDeterministic）、是否与文件系统交互、是否处理敏感数据等。这样的标记可以帮助开发者在编译／静态分析阶段检测不希望发生的调用或副作用。
* 有人指出，即便现在没有语言内建支持这些标记／效果系统（effects），有些模式可以手工实现，比如把文件系统依赖作为参数传递，或使用协议封装。只是这些做法在代码量／样板上会变得复杂。

潜在方向与挑战

* 扩展语言以支持 效果系统／函数标色(effect annotations)，让编译器能在类型系统层面了解函数副作用。
* 在语言中加入机制以强制或支持引用透明（或更强的不变性）编程风格。
* 提供语法糖／DSL／语言构造，使得声明式风格更自然、更易用，并能在 UI 之外场景也通用。
* 一大挑战是如何让这些特性兼容现有生态，同时不使语言变得过于复杂／难学。还有效率与性能安全等问题：标色／效果检查是否会引入编译开销？函数调用路径的副作用检测能否做到静态可靠？

总结

这是一场较为开放性的未来语言方向讨论，社区整体认可声明式编程风格在 Swift 中的重要性，并希望能在未来版本中看到更强力的语言支持，比如效果系统、副作用标识、引用透明性等。虽然没有具体提案进入实现阶段，但这个方向被认为对提升代码安全性、可测试性、可组合性及整体可维护性非常有价值。


5、讨论[@unknown default 的用途与新规则](https://forums.swift.org/t/whats-the-deal-with-unknown-default/82150 "@unknown default 的用途与新规则")

作者 Bawenang (Bawenang Rukmoko) 在帖子中提出一个问题：在 Swift 6 模式下，对通过 switch 匹配一个可能来自外部库的 non-frozen 枚举（Variant）时，即使所有已知 case 都被覆盖，编译器也报错（“may have additional unknown values; this is an error in the Swift 6 language mode”），并强制要求加上 default 或 @unknown default。作者想知道：为什么现在 default 是必须的？有没有办法让代码故意不含 default，以便在未来为新增 case 强制编译错误，而不是默默忽略。

社区反馈与解释

* Swift 官方文档与核心团队解释说，对于 non-frozen 枚举，如果你依赖库演化（library evolution mode，即库可以新增 case 而不重新编译使用者代码），就必须包含一个 default 或 `@unknown default` 分支，即使在当前所有 case 都显式列出。这个要求是为了避免未来枚举新增 case 导致未被 switch 覆盖而造成未定义行为或运行时错误。
* 使用 `@unknown default` 的好处在于，当枚举未来新增了 case，并且你重新编译使用者代码时，编译器会发出警告提醒你：有 case 新增未被显式处理。相比之下，仅用 default 的话，就不会有警告，你可能不知道 library 更新了枚举。
* 如果你确实希望编译器在枚举新增 case 时 switch 语句报错（而不仅仅是警告），可以通过将枚举标记为 @frozen 或关闭 library evolution（不开启 “Build for Distribution” / -enable-library-evolution）来实现。这样枚举被视为不会新增 case，switch 可被视为完全穷尽，不需要 default。
* 还有一个“包内模块”（same Swift package 内的模块）之间的情况：如果枚举定义与使用在同一个 package 中并一同编译，编译器假设这些模块会被同时更新，因此可能不强制要求 default。但强迫这种做法可能有构建工具或包管理器方面的限制。

总结

这个讨论主要是澄清 Swift 语言在 non-frozen 枚举上对 switch 语句的新规则：在开启 library evolution 的情况下 默认必须有一个 fallback 分支（default 或 @unknown default），以保证向后兼容性和安全性。@unknown default 在这种情形下被推荐，因为它能在未来枚举新增 case 时提醒开发者修改代码。若希望不使用 fallback 并让添加 case 时变为编译错误，需要使枚举稳定（@frozen）或不启用库演化模式。

## 推荐博文

[ Swift 6 并发编程：深入理解 @unchecked Sendable 的合法使用与陷阱](https://juejin.cn/post/7551325915759771674/ " Swift 6 并发编程：深入理解 @unchecked Sendable 的合法使用与陷阱")

**摘要：**  本文围绕 Swift 并发编程中的 `@unchecked Sendable` 展开，探讨了它的由来、用途与使用风险。在 Swift 引入结构化并发后，Sendable 协议成为类型能否跨并发域安全传递的重要约束。但在现实开发中，许多类型虽然本质线程安全，却无法通过编译器的自动判断。这时，`@unchecked Sendable` 提供了一种手动声明线程安全的方式，让开发者在编译器放手的前提下自行负责并发正确性。

文章强调，`@unchecked Sendable` 并非万能解药，必须建立在实际线程安全的基础之上，如通过队列、锁等机制保护可变状态，或仅使用不可变数据结构。滥用这种标记可能导致难以发现的并发错误。相比之下，Swift 的 Actor 模型提供更完善的并发隔离机制，虽然语法上更具侵入性，但更适合新项目或清晰的逻辑边界。

为了确保自定义类型真正具备线程安全性，建议借助工具如 Thread Sanitizer 进行高强度测试，并在代码中明确记录同步方式与测试结果。最终目标不是单纯地消除编译器警告，而是构建可靠、可维护的并发代码体系。

[Swift 6.0 协议扩展：解锁协议新特性，写出更优雅、更高效的代码](https://juejin.cn/post/7551300910414151695/ "Swift 6.0 协议扩展：解锁协议新特性，写出更优雅、更高效的代码")

**摘要：**  这篇文章聚焦 Swift 6.0 中协议扩展的五项重大升级，展示了协议从简单的“能力描述”工具演进为真正强大的抽象机制。通过引入参数化扩展、静态派发优化、带约束的默认实现、扩展级注解以及更灵活的类型约束，Swift 协议扩展变得更加灵活、精确和高性能。

文章以丰富的代码示例，逐一讲解每项新特性的用法与适用场景，并强调这些能力在架构设计中的价值。例如，通过参数化扩展，开发者可以为特定条件下的类型提供额外功能；静态派发让协议方法拥有与结构体方法相同的性能；带约束的默认实现支持“按需分发”逻辑，而扩展级注解则简化版本控制与 API 管理。

在实战环节，作者通过一个“缓存系统”的完整案例，把五个特性串联起来，展示协议扩展如何在不引入基类或复杂继承的情况下，实现模块化、平台差异化与性能最优化的设计。

文章最后指出，这些新能力让协议扩展从“省代码”变成了构建领域模型、管理平台差异、进行高性能抽象的重要工具。未来在 SwiftUI、数据建模、DDD 等方向上，它都将发挥更大的作用。

[@isolated(any) 深度解析：Swift 并发中的“隔离追踪器”](https://juejin.cn/post/7550635630289584169/ "@isolated(any) 深度解析：Swift 并发中的“隔离追踪器")

**摘要：**  这篇文章介绍了 Swift 6 并发新特性 `@isolated(any)`，它的作用是保留函数的 actor 隔离信息，确保函数在并发执行时知道该在哪个线程或 actor 上运行。

以前 async 函数作为参数传递时，会丢失像 `@MainActor` 这样的隔离信息，导致无法保证顺序或正确调度。使用 `@isolated(any)` 可以解决这个问题，让调度器正确安排任务，并且还能通过 `.isolation` 属性查看函数属于哪个 actor。

它的主要应用场景是：写任务调度器、并发框架，或者需要严格控制执行顺序的地方。对普通业务代码来说，大多数时候你可以忽略它。

一句话总结：
`@isolated(any)` 就像函数的“隔离身份证”，让它在并发中能被正确、安全地调度执行。

## 关于我们

**Swift社区**是由 Swift 爱好者共同维护的公益组织，我们在国内以微信公众号的运营为主，我们会分享以 **Swift实战**、**SwiftUl**、**Swift基础**为核心的技术内容，也整理收集优秀的学习资料。

欢迎关注公众号:Swift社区，后台点击进群，可以进入我们社区的交流讨论群。希望我们Swift社区是大家在网络空间中的另一份共同的归属。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
