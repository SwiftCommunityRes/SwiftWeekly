## 前言

嗨，Swift 社区的小伙伴们～👋

欢迎来到 **第 90 期 Swift 周报**！每周陪你一起跟进动态、学点新东西、再顺便聊点和 Swift 相关但不止于 Swift 的话题～

本周也一样，先送上一小段给你们的 **能量文**：“草木需要阳光，生活需要向往。崭新的一天， 愿你从容前行，邂逅每一缕芬芳，拥抱每一份希望。👊👊👊”

> **周报精选**
>
> * 新闻和社区：苹果CEO库克退休？
> * 提案：
> * Swift 社区：
> * 推荐博文：

**上期话题投票结果**



根据投票结果大家如何看待？

## 本期话题讨论

欢迎在留言区说说你的理由，下期我们公布统计结果！
（别只投不说，大家都爱看你们的观点～）

## 新闻和社区

### 苹果公司原始合伙协议即将拍卖，估价高达400万美元

**2025 年 11 月 26 日**

消息称，佳士得拍卖行即将于 2026 年 1 月 23 日拍卖 1976 年 4 月 1 日创立苹果电脑公司的原始合伙协议，其估价约为 200 万至 400 万美元（IT之家注：现汇率约合 1418.3 万至 2836.5 万元人民币）。

![](image.png)

这份原始三页文件由史蒂夫・乔布斯（Steve Jobs）、史蒂夫・沃兹尼亚克（Steve Wozniak）与罗恩・韦恩（Ron Wayne）三方签署，确立了公司初始股权结构：乔布斯与沃兹尼亚克各占 45%，韦恩占 10%。

此次拍卖还包含韦恩在公司成立仅 12 天后即退出合伙的相关补充文件。当时，韦恩以 800 美元将其 10% 的股份售出，此后又获得一笔 1,500 美元的额外付款。

韦恩后来表示，他选择退出是因为预见到该创业项目将是一场“过山车式”的高风险旅程，而这样的高风险挑战并不适合他。

若韦恩当年的 10% 原始股份得以完整保留至今，按苹果公司当前约 4 万亿美元的估值计算，其价值将高达约 4,090 亿美元。不过需特别说明的是，这一数字仅为趣味性类比，因为历经数十年的多次股票分拆、新股发行及公司架构调整，早期的 10% 股权在现实中已与苹果当前的股本结构毫无关联。

佳士得此次将把创始合伙协议与韦恩退出协议作为单一拍品进行拍卖。值得注意的是，韦恩于 20 世纪 90 年代初曾以 500 美元的价格出售过该创始协议的纸质原件；而苹果公司原始注册文件上一次现身拍场是在 2011 年 12 月，由苏富比拍卖行拍出，当时该拍品亦包含韦恩的退出协议，最终以近 160 万美元的价格被一位私人藏家购得。（来源：IT之家）

### 消息称苹果再次裁减销售团队部分员工 两年前曾有过精简

**2025 年 11 月 25 日**

11 月 25 日消息，据外媒报道，在 2022 年和去年，包括特斯拉、英特尔、微软、亚马逊、谷歌母公司 Alphabet 等在内的多家科技巨头，有过较大规模的裁员，其中微软、亚马逊、谷歌母公司 Alphabet 在 2022 年下半年均是裁员过万。

在 2022 年和 2024 年这两轮科技领域的大裁员中，苹果是一股清流般的存在，他们并没有大规模的裁员，只是有消息称他们分两次裁减了数百名外包员工，也冻结了研发之外大部分的招聘工，2023 年年初也有消息称精简了零售团队，裁减了部分员工。

而从外媒最新的报道来看，在 2023 年精简零售团队两年之后，苹果再次裁减了销售方面的部分员工。

外媒的报道显示，苹果这一次小规模的裁员，是在近几周进行的，受影响的员工有数十名，是销售团队中面向教育、政府及学校客户的员工，被裁的员工，在过去的两周收到了裁员通知。

外媒在报道中还提到，苹果已经向部分外媒确认了销售团队裁减部分员工的消息，苹果表示，为了联络更多的客户，他们对销售团队进行了部分调整，部分员工的职位受到了影响。

虽然进行了裁员，但苹果也表示他们将继续招聘，销售团队受到裁员影响的员工，也可申请苹果公司的其他职位，他们有一个月的时间申请其他合适的岗位，如果在 1 月 20 日之前仍未找到合适的岗位，苹果就将支付补助，并遣散他们。

对于苹果公司此次对销售团队的裁员，受影响的员工认为苹果希望将更多的销售工作转向第三方零售商，通过减少自身在销售方面的支出，来节省成本。（来源：新浪财经）

### 苹果CEO库克退休？知名爆料人辟谣

**2025 年 11 月 25 日**

据央视财经综合多家外媒报道，美国苹果公司的首席执行官（CEO）蒂姆·库克有可能最早于明年卸任，苹果公司目前正在加紧物色库克的继任者，而现任公司硬件工程高级副总裁特努斯则被普遍视为最有可能的继任者。

同时，还有媒体报道说，预计苹果公司还有多位高级管理人员也将在明年离职或退休，而这将是苹果公司十多年来面临的规模最大的一次人事变动。

![](https://pics3.baidu.com/feed/d0c8a786c9177f3e38bb8a6237c2e8d79e3d56eb.jpeg@f_auto?token=e76125c024312ae30e8ba030b65d7ac7)

不过，此消息目前可能面临翻转。在最新通讯中，知名苹果公司爆料人马克·古尔曼言辞肯定地辟谣“苹果 CEO 蒂姆·库克即将于明年上半年退休”，同时透露 OpenAI 正在以惊人的速度挖角苹果员工，让消费电子巨头甚是不爽。

库克辞职传言“纯属虚假”？

对于“库克会在明年 1 月底（下一份财报公布后）至明年 6 月年度开发者大会之间辞职”的传言，古尔曼直言，根据他近几周了解到的消息，库克不太可能在明年 6 月前离职。

事实上，如果这条传言为真，他将会感到震惊。另外，对于有些人将此视作苹果公司提前放出“试探气球”，以便让华尔街提前适应，古尔曼也表示，事实并非如此，那篇报道纯属虚假（thestorywassimplyfalse）。

古尔曼补充道，硬件工程高级副总裁约翰·特努斯的确处于“接班库克”相关讨论的核心位置，原因也很简单：今年 50 岁的特努斯是苹果高管团队中最年轻的一员，拥有最长的潜在任期。而且特努斯身处新设备开发的核心位置，且受到库克高度认可。

因此，知名爆料人总结称，如果没有迫使库克提前辞职的意外事件，这一时刻将不会很快到来。话虽如此，苹果高管团队的震动仍将继续，负责芯片业务的约翰尼·斯鲁吉正在评估他在公司的未来，苹果也在物色新的人工智能负责人。

苹果硬件工程师批量跳槽 OpenAI

与长期稳定的高管团队相对，眼下苹果的硬件工程团队正迎来一波 OpenAI 的“Offer 热潮”。

作为“AI 叙事”的一部分，OpenAI 收购前苹果设计主管 JonyIve 创办的设计公司 io 后，正朝着 2026 年发布首批 AI 硬件而努力。最新的爆料也显示，OpenAI 的硬件梦想，主要靠挖角苹果来实现。

古尔曼透露，仅在过去一个月里，OpenAI 的硬件团队就招聘了 40 多人，其中许多人来自苹果的硬件工程团队。被挖走的苹果员工中，不乏关键主管（相当高级的岗位），还有部门经理和工程师。

他们来自的领域也相当广泛，包括相机工程、iPhone 硬件、Mac 硬件、芯片、设备测试与可靠性、工业设计、制造、音频、智能手表、VisionPro、软件以及人体工程学等。换句话说，OpenAI 正在从几乎所有相关的苹果部门吸纳人才。

毫无疑问，苹果公司对 OpenAI 的“扫荡式挖角”很不满意，内部也有人将其上升到“问题”的层面。

当然，问题并不只是 OpenAI 的挖角。上周也有消息称，iPhoneAir 设计师、苹果工业设计团队的冉冉升起新星阿比杜尔·乔杜里已经离开苹果，加入了一家人工智能初创公司。

古尔曼感慨称，这一系列离职也反映出苹果难以留住关键基层人才的现状。曾几何时，员工愿意为了在苹果工作而接受较低的收入，但现在这种情形已经不是主流看法。（来源：金羊网）

## 提案


## Swift论坛
### 1、提案 Task Cancellation Shields（任务取消屏蔽）

作者：Konrad ‘ktoso’ Malawski 🐟🏴 | 发布日期：2025 年 11 月 23 日

[查看原帖](https://forums.swift.org/t/pitch-task-cancellation-shields/83379, "提案 Task Cancellation Shields（任务取消屏蔽）")

这个提议提出为 Swift Concurrency 增加新的机制——“取消屏蔽 (cancellation shield)”，允许某段代码在其作用域内 忽略任务取消 (cancellation) 的影响，从而保证即使任务被取消，该段代码仍会执行 — 常见用途如清理 (cleanup)／释放资源／确保最终状态一致等。

✅ 背景与动机
* 在当前 Swift 的并发模型中，任务取消 (Task.cancel()) 是“协作式 (cooperative)”的 —— 被取消的任务并不会强制终止，而是在下一个等待 (await) 点抛出 CancellationError 或根据 Task.checkCancellation() 手动检查取消状态。  ￼
* 但是在某些场景（例如资源清理、网络请求回调、文件/数据库关闭等），开发者可能希望即使任务取消，也能强制执行“必须做”的收尾逻辑。目前一般 workaround 是用 withTaskCancellationHandler 或 spawn 新任务，这带来了样板、多余的不确定性。
* 此前已有对 async defer 的扩展提案（允许在 defer 中 await），即为了解决类似清理逻辑的问题。Task Cancellation Shields 可视为该方向的进一步补充，提供系统级、语法/运行时层面的支持。  ￼


🔧 提案内容与 API 设想
* 引入一个新的 API：例如 withTaskCancellationShield { … }。在其闭包 (closure) 内，取消请求对这段代码不起作用 —— 即使外层任务已被取消，该闭包也会完整执行。  ￼
* “屏蔽”取消并不会阻止任务的取消状态，仅仅使被包裹代码 无法观察到 取消 (例如不会因为 Task.isCancelled == true、不会抛 CancellationError、也不会触发 cancellation handlers) 。  ￼
* 任务的子任务 (child tasks) 仍然可以被取消并感知取消 —— 屏蔽只针对封装块本身生效。  ￼
* 通过这种机制，可以在 defer、清理、资源回收、状态同步等语义关键区块中保证可靠执行，而不受外部取消影响。

示例伪代码：
```Swift
defer { 
  await withTaskCancellationShield {
     try await cleanupResources()
  }
}
```


👍 社区反应 / 支持理由
* 多名开发者和社区成员表达强烈支持，认为这是“构建结构化并发 (Structured Concurrency) 时的核心需求之一”。  ￼
* 一位评论者指出，当下常见 workaround（如 Task.value { … }.value）很笨重，且语义不清晰，而 cancellation shield 是更干净、更安全、更系统的解决方案。  ￼
* 还有支持者强调，这样的机制有利于让 cleanup / teardown 代码更易写、更可靠，也方便库或框架层抽象资源管理逻辑。  ￼


⚠️ 潜在问题 / 讨论焦点

虽然多数反馈积极，但这个提案也引起了关于语义与一致性的讨论 — 比如：
* 取消语义 vs 清理语义：允许忽略取消可能破坏对取消语义 (cancellation contract) 的一致理解 —— 本来取消意味着“放弃执行”，但 shield 会让某些代码绕过这一语义。需要文档／规范明确哪些场景适合屏蔽取消。
* 滥用风险：如果大量代码都被 shield 包裹，可能导致取消失效 (cancellation meaningless)，从而降低 cancellation 对资源回收 /响应用户取消的效果。
* 子任务与继发取消：shield 内部启动的新任务是否也受 shield 保护？当前说明是子任务仍可取消 —— 这意味着 shield 只针对当前同步/异步 block，不会“屏蔽全局取消传递”。这种设计是折中，但可能让模型更复杂。  ￼


📄 小结

Task Cancellation Shields 提案为 Swift 并发带来了一个很实用、也很必要的新语义——允许开发者在面对协作式取消 (cooperative cancellation) 时，为关键清理逻辑加上一道“屏蔽层”，确保资源释放、状态恢复或日志写入等工作能可靠执行。这对于资源管理、网络请求、文件 I/O、clean-up、defer/cleanup 模式、库设计都有潜在助益。

### 2、提案“可检测 Task 执行时间”的功能￼

作者：Swift Testing Workgroup / Maarten Engels ｜ 发布日期：2025 年 11 月 24 日

[查看原帖](https://forums.swift.org/t/possible-feature-inspect-task-execution-time/83396, "提案“可检测 Task 执行时间”的功能")

这条帖子讨论了一个潜在特性 —— 在 Swift 并发模型中，允许用户“检查 / 度量一个 Task 在实际运行 (executing / working) 时所消耗的时间 (CPU-time / active execution time)”。作者表示已有实验性实现，目前希望征集社区对此功能的需求、用途与反馈。 ￼

为何提出
* 目前在并发环境中 (尤其是测试 /异步任务密集场景) 很难区分一个 Task 是“活动执行中 (running / working)” 还是“挂起 / 等待中 (suspended / waiting)”。这使得基于 wall-clock time 的超时 /性能度量不可靠。 ￼
* 如果能测量真正的运行时间 (不包含挂起 /等待)，将更加准确地进行性能剖析 (profiling)、测试超时控制、资源监控等。尤其在非 Apple 平台、无法使用 Instruments 等工具时，这可能是非常有价值的调试手段。 ￼

提案内容 / 设想
* 为 Task 添加 API，让使用者能够获取 Task 的实际运行时间 (execution time)，包括其子任务 (child tasks) 的运行时间，但排除其挂起 /等待期间。 ￼
* 该功能主要定位于测试、性能监控与调试场景。作者欢迎社区讨论其可能的广泛用途，以及对 API 设计、命名、安全性 / 隐私 (例如是否记录敏感信息)、测量精度 /开销等方面的建议。 ￼

潜在用途 (不仅限于测试)
* 性能剖析 (profiling)：衡量某个异步任务在真实 CPU 执行上花费多少时间，比仅看 wall-clock 更可靠。
* 超时 /资源限制判断：对 Task 的实际执行时间 (而非挂起时间) 设定限制，更准确地判断“活跃计算”是否过久。
* 多平台兼容：在不支持原生 profiling / Instruments 的平台 (如 Linux) 上，也能通过 Swift 提供的 API 做性能监控。
* 负载分析 /监控：用于长运行或后台服务中的异步工作量统计，帮助判断负载、资源消耗与调度效率。

总结

这项提案虽仍处于探索阶段，但它旨在填补 Swift 并发当前的一大盲区 —— 没有手段测量 Task 的真实执行时间 (active runtime)。如果采纳，它将为测试、调试、性能监控以及跨平台支持带来实质性好处。

对你的项目或团队来说，这意味着未来有可能：
* 精准地判断异步任务耗时／性能瓶颈
* 为测试／基准 (benchmark) 提供更可靠、与挂起时间无关的度量
* 在非 Apple 平台上构建监控 / 诊断工具


### 3、什么是 “potential suspension point”（潜在挂起点）？

作者：ibex10 ｜ 发布日期：2025 年 11 月 23 日

[阅读原帖](https://forums.swift.org/t/what-is-a-potential-suspension-point/83375, "什么是 “potential suspension point”（潜在挂起点）")

这篇帖子讨论了在 Swift concurrency 中经常提到的术语 “potential suspension point”（潜在挂起点） 的真正含义，以及它与实际挂起（suspension）的区别。

核心内容：
* 在 Swift 中，每当你对一个 async 函数调用前加上 await，这个 await 就被认为是一个 潜在挂起点。  ￼
* “潜在挂起点”并不保证一定会挂起 —— 它只是“可能会”挂起。是否真的挂起，取决于被调用函数链中是否有实际做出挂起的动作（例如执行 I/O、调用 Task.yield()、等待锁、等待网络响应等）。  ￼
* 举例说明：
```Swift
func maybeSuspend(_ shouldSuspend: Bool) async {
  if shouldSuspend {
    await Task.yield()
  } else {
    await say("life goes on")  // say 只是普通 async，但不挂起
  }
}
```
* 如果 shouldSuspend == true，调用 maybeSuspend(true) 会真正挂起，因为执行了 Task.yield()。
* 如果 shouldSuspend == false，即使写了 await, 调用 maybeSuspend(false) 也 不会挂起 —— 因为它调用的是一个不会挂起的 async 函数。  ￼

* 一句话总结：“await = potential suspension point”, 只是告诉编译器 “这里可能会暂停”，但不保证一定暂停。  ￼

为什么 “potential suspension point” 很重要
* 并发安全 / Actor 隔离 /可重入性 —— 任何带 await 的地方，都可能是任务挂起／恢复点。如果你在 actor 内部写 await，挂起期间可能有其他任务进入 actor，从而改变状态。这是 actor 重入 (re-entrancy) 风险的重要来源。  ￼
* 取消 /超时 /资源清理 —— 因为挂起是动态的，不是所有 await 都会暂停，所以在设计 async 函数时，若需要在挂起后恢复清理逻辑、检查取消状态等，就必须假设可能挂起 (即 treat every await as a real suspension), 而不是依赖 “调用不挂起” 的假设。
* 性能 /调试 / scheduler 行为 —— 编译器将 async 函数转译成状态机 (state-machine)，await 是状态切换点 (yield / resume)。了解哪些点是 “潜在”的挂起，有助于分析性能、线程切换、任务切换、调试断点等。  ￼

总结
* “潜在挂起点 (potential suspension point)” ≠ “真正挂起点 (actual suspension)” — 它只是一个可能挂起的地方。
* 每个 await 都是潜在挂起点 — 即使实际不会挂起，我们也应当假设可能挂起，以保证并发安全、actor 隔离、取消处理等正确性。
* 对于 Swift 并发 (async/await) 编程者来说，理解这一点非常关键 — 它影响我们对状态一致性、调度、取消、资源管理、性能等方面的设计和预期。

### 4、讨论：Running func on Background —— 在后台线程运行普通函数

作者：EngOmarElsayed ｜ 发布日期：2025 年 11 月 23 日

[阅读原帖](https://forums.swift.org/t/running-func-on-background/83378, "讨论：Running func on Background —— 在后台线程运行普通函数")

这篇帖子讨论了在使用现代并发特性（Approachable Concurrency）时，如果当前上下文为主 actor（UI 线程），但希望将某个普通（non-isolated／non-async）函数“丢到后台线程执行”，有没有合适方式 —— 特别是为了后台任务（如 analytics、日志、轻量后台处理），而不希望该函数阻塞主线程，也不想将其转成 async。

🔎 背景与问题
* 提问者表示，他有一个函数希望在后台执行，因为它涉及与 UI 无关的后台逻辑（例如 analytics），而当前调用者常为 @MainActor。但他不想将这个函数声明为 async。  ￼
* 因为 caller 是 MainActor，如果直接调用，会运行在主线程，不适合耗时或后台逻辑。

💡 讨论与建议方案

社区成员给出了几种思路：
* 使用 Task.detached
最简单、直接的方法是用 detached task 将函数丢到后台执行 — 例如：
```Swift
public func identify(event: IdentifyEvent) {
  Task.detached {
    self.identifySynchronous(event: event)
  }
}
```
这样不依赖当前 actor，也不要求函数为 async。  ￼

* 如果需要 await，或希望利用并发特性，也可以使用 @concurrent + async wrapper
即为逻辑包一层 async 函数，并用 @concurrent 标记，让它不继承 MainActor，再从主线程触发。  ￼
* 对于“fire-and-forget”（只记录、发送事件，无需等待结果）的场景，建议使用一个线程安全的事件队列 + 异步流 (e.g. AsyncStream) 模型：主线程同步提交事件到队列，由后台专门处理流中的事件，保证顺序与线程安全性。  ￼

“你仍然需要异步 somewhere，因为要从当前 actor 跳出，这是异步的本质。” —— 论坛回应者指出，要跳出 actor，就必然涉及挂起 /切换执行上下文。  ￼

✅ 总结建议
* 如果你只是想在后台运行一个普通同步函数，不需要等待返回，也不依赖 actor 隔离状态，最简单的是使用 Task.detached { … } — 兼容性最好、代码也最清晰。
* 如果你希望保持顺序、线程安全，并可能有较多后台任务 (event-driven、analytics、日志等)，考虑“事件队列 + AsyncStream / 消费器” 模式。这样可以集中后台处理逻辑，避免并发任务间竞争，也更可控。
* 避免仅仅因为“想后台”就把函数转成 async — async／await 并不自动意味着“线程切换”。真正切换线程或 executor 的方式是 detached task / non-actor async / global executor。  ￼

### 5、讨论：Swift Package Manager (SwiftPM) 是否应该停止 “默认为很低 macOS 版本”的行为

作者：MahdiBM ｜ 发布日期：2025 年 11 月 27 日

[查看原帖](https://forums.swift.org/t/can-swiftpm-not-default-to-low-macos-versions/83441, "讨论：Swift Package Manager (SwiftPM) 是否应该停止 “默认为很低 macOS 版本”的行为")

这篇帖子讨论了一个影响 Swift 包生态兼容性和新特性使用门槛的问题 —— 目前 SwiftPM 默认支持非常老旧的 macOS 版本，这给使用新语言或库特性的开发者带来了不便。作者提议：SwiftPM 应该“抬高”默认 macOS 最低版本要求，而不是保留过低默认版本。

🔎 背景与问题
* 以某个库（例如 swift-nio）为例，作者希望在库中使用新引入的底层类型如 Span —— 这些类型依赖较新的标准库/运行时支持，不在非常旧的 macOS 版本中可用。因为 SwiftPM 的默认最低版本设得很低 (例如 10.12)，库想兼容默认设定时，就无法把这些现代特性暴露在主 API 中。 这样一来，为了兼容旧系统，开发者不得不回退到较旧 / 较弱 / 不够理想的实现方式。 ￼
* 换句话说，旧的默认最低部署目标限制了包作者“使用现代 Swift /新标准库功能 + 同时兼容所有被 SwiftPM 默认支持的系统”—— 造成了一种 “向后兼容 vs. 新功能使用” 的两难。

💡 社区讨论与观点
* 提高默认最低版本：部分用户建议，SwiftPM 的默认 macOS 最低版本应该提升（例如设为 10.15 或更高），这样库可以直接使用现代特性 (如 Span、back-deployed API 等) 而无需每处加 availability 判断或为旧系统保留 fallback。 ￼
* 当前机制不完全阻止使用新特性：也有人指出，目前在包中仍可以手动设置 platforms 字段（在 Package.swift 中指定 minimum macOS version），或在某些 API 上添加 @available(...) 注解，以兼容不同系统版本。也就是说，并不是“绝对不可能用”。 ￼
* 依赖关系 & 兼容性复杂性：一个难点是，若一个包 A 提升了最低部署目标，而另一个包 B 仍然保持旧版本，两者之间的依赖关系可能变得复杂。特别是对于广泛用作基础库 (like swift-nio) 的项目，这种变更可能引发兼容性问题。 ￼

✅ 为什么这个提议值得重视
* 降低使用现代功能的门槛：如果默认最低版本不是那么老旧，库作者可以更大胆地使用现代 Swift、新标准库 / runtime 特性 (Span、back-deployed APIs、其它补丁)；这样整个生态能更快迁移到新特性。
* 减少兼容性样板代码：当前为了同时兼容老系统和使用新功能，很多库不得不写大量 availability 检查或 fallback 实现，这既冗余又容易出错。抬高默认版本可以简化代码。
* 规范化现代包生态：现代的 macOS 用户多数都运行 fairly recent 版本，设定较新的最低版本可以更贴近真实用户环境，从而让库设计与现实更一致。

⚠️ 风险与挑战
* 排除旧系统支持：将默认最低版本抬高意味着部分老系统/设备可能无法运行新包，这对某些仍服务老 macOS 用户群的项目而言是问题。
* 依赖链兼容性问题：部分较旧依赖可能仍要求低 macOS 版本，如果改变默认最低版本，会让它们难以兼容或需要 fork／重构。
* 消费者 / 应用作者承担更多判断责任：对于使用库的人，需要留意目标运行环境是否满足最低版本要求，可能需要额外测试或兼容性处理。

📄 小结

这条讨论为 Swift 包生态带出了一个值得深入考虑的问题 — 当现代 Swift / 标准库 / runtime 功能不断推进时，保持对极旧系统的默认支持 可能反而成为一种阻碍，而不是保障。将 SwiftPM 的默认最低 macOS 版本“抬高”——从而简化现代功能使用、减少兼容样板、提升生态总体质量——是一个具有说服力的提议，尤其对那些愿意放弃对非常老系统支持的库/项目而言。


## 推荐博文

[使用 Foundation Models 框架在 Swift 中构建AI功能](https://juejin.cn/post/7549113302673883146/ "使用 Foundation Models 框架在 Swift 中构建AI功能")

**摘要：** 苹果的 Foundation Models 框架让开发者能用 Swift 代码轻松地为 App 加入 AI 功能。
使用这个框架，你可以做两件主要的事情：一是让 AI 生成对话、建议等普通文本；二是让 AI 直接生成格式规整的结构化数据，比如自动把用户输入的营养信息填充到一个定义好的数据模型里，用起来非常方便。
文章通过健康助手、食谱生成等例子，一步步展示了如何从检查设备是否支持 AI，到创建会话，再到最终实现文本和结构化内容生成。整个过程充分利用了苹果设备的性能，并且能保护用户隐私。

[iOS 开发者的安全加固工具，从源码到成品 IPA 的多层防护体系实践](https://juejin.cn/post/7577587651894100009/ "iOS 开发者的安全加固工具，从源码到成品 IPA 的多层防护体系实践")

**摘要：**  本文为 iOS 开发者提供了一套完整的安全加固实践方案。文章指出，在真实开发环境中，单纯依赖某个单一加固工具远远不够——从源码泄露、符号暴露到 IPA 被反编译、资源被篡改，安全威胁遍布应用生命周期的各个环节。

因此，作者提出应建立一套覆盖静态分析、源码混淆（可选）、IPA 加固、资源保护、重签验证、逆向对抗及符号治理的多层防护体系。文中详细梳理了各阶段对应的工具矩阵与落地流程，特别强调了无需源码即可实现 Swift/ObjC 符号混淆与资源扰动的 Ipa Guard CLI 在工程实践中的核心价值。

通过这一工具组合与标准化流程，开发团队能够系统性地构建可控、可测试、可长期维护的安全能力，真正实现从源码到成品 IPA 的全链路防护。

[手游频繁崩溃闪退原因分析与 iOS 崩溃日志解析方法](https://juejin.cn/post/7576479344038658100/ "手游频繁崩溃闪退原因分析与 iOS 崩溃日志解析方法")

**摘要：**  本文系统介绍了手游频繁崩溃闪退的原因分析与iOS崩溃日志解析方法。文章首先从玩家体验和开发维护角度阐述了崩溃问题的严重性，随后深入剖析了两大类崩溃原因：一是违反iOS系统规则导致的内存报警、响应超时和用户强制退出；二是应用逻辑Bug引发的段违例、中止信号等常见错误。

在崩溃收集方面，文章详细比较了商业工具、开源方案和自定义日志收集的优缺点，特别针对当前主流手游采用的引擎+脚本开发模式，提出了相应的日志收集策略。对于崩溃日志解析，重点介绍了symbolicatecrash工具和atos命令两种实用的符号化解析方法，通过具体案例演示了如何从杂乱的崩溃日志中准确定位问题代码。


## 关于我们

**Swift 社区** 是由 Swift 爱好者共同维护的技术组织，主要通过微信公众号运营。

我们专注于 **Swift 实战、SwiftUI、Swift 基础** 三大方向，每周为你带来精选内容与最新生态资讯。

**关注公众号：「Swift社区」**
后台回复 “进群” 即可加入开发者交流圈。

<img width="500" alt="Swift社区" src="https://user-images.githubusercontent.com/24238160/132703149-34121c6c-fd18-491c-a697-58a0fabf3060.png">

特别感谢 Swift社区 编辑部的每一位编辑，感谢大家的辛苦付出，为 Swift社区 提供优质内容，为 Swift 语言的发展贡献自己的力量。
